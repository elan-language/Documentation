<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-GB">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="Documentation.css" rel="stylesheet">
<link href="colourScheme.css" rel="stylesheet">
<link href="elanStyle.css" rel="stylesheet">
<title>Elan Language Reference</title>
<script type="text/javascript" src="generated_toc.js"></script>
</head>
<body>

<div class="docTitle">Elan Language Reference</div>

<div class="docTOC">
	<div id="generated-toc" class="generate_from_h1 generate_for_page"></div>
</div>

<!-- #region Instruction Set-->
<!--   #region Heading & Intro-->
<h1 id="Instuction_set">Instruction Set</h1>

<p>This section defines the set of instructions that make up the Elan language, and which form the building blocks for any program.</p>
<p>There are three categories of instruction, which are distinguished where the instructions of that categeory are <em>located</em> within a program:</p>
<li><a href="#Global">Global instructions</a> (also referred to simply as 'globals') are located <em>directly</em> within a code file.
  They are never indented from the left-hand edge, nor may they be located <em>within</em> other instructions.
  Three of the globals - main, function, and procedure - are described as 'methods' and these defined one or more <a href="#Statement">statements</a> within them.</em><div class="">
  Four of the globals - <a href="#record">record</a>, <a href="#class">class</a>, <a href="#Abstract_class">abstract class</a>, and <a href="#interface">interface</a> - define data structures and these always contain <a href="#Member">members</a>.
  The two remaining globals - constant, and enum - do not contain any further instructions.</li>
<li><a href="#Member">Member instructions</a> (also referred to simply as 'members') are located directly within the 'data structure' globals: record, class, abstract class, interface.
  All members with the exception of property, define one or more <a href="#Statement">statements</a> within them.
</li>
<li><a href="#Statement">Statement instructions</a> (also referred to simply as 'statements) are located within 'methods.
Some of these statements may contain other statements. </li>

<p>All instructions are added into a program using the <el-code>new code</el-code> 'selectors'.</p>

<h2 id="Comment">Comments</h2>
A comment is not an instruction: it will be ignored by the compiler and does not change how the program works.
Rather, a comment contains information <em>about</em> the program, intended to be read by a person seeking to understand or modify the program.
Every comment starts with the symbol <el-code>#</el-code> (known as 'hash') followed by some text or a blank line.
Comments can be inserted by a programmer at the same level as a <a href="#Global">global</a>,
<a href="#Member">member</a>, or <a href="#Statement">statement</a> instruction, by entering <el-code>#</el-code> from the <el-code>new code</el-code> selector.</p>
<p> Every Elan program has a single comment at the top of the file, which is generated by the system and may not be edited or deleted by the user.
  This comment is known as the 'header' and gives the version of Elan being run, together with other optional information depending upon your user profile.</p>
<!-- #endregion-->
<!--   #region Global Instructions-->
<!--     #region Heading & Intro-->
<h2 id="Global">Global Instructions</h2>

<p>When you navigate to a <el-code>new code</el-code> that is at <em>global</em> level (not indented from the left-hand edge of the code pane)
you will be shown the set of globals that may be inserted there, for example:</p>

<el-code><el-global class="selected focused ok empty" id="select0" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-select><el-txt></el-txt><el-place>new code</el-place><el-help class="selector"> main procedure function test constant enum record class abstract interface #</el-help></el-select></el-global></el-code>

<p>The specific globals offered will depend upon your user profile. The full set of globals is shown here with links to explanations below:</p>

<a href="#main">main</a>,
<a href="#Procedure">procedure</a>,
<a href="#Function">function</a>,
<a href="#Test">test</a>,
<a href="#Constant">constant</a>,
<a href="#Enum">enum</a>,
<a href="#record">record</a>,
<a href="#class">class</a>,
<a href="#ClassAbs">abstract</a> (in this context, short for <el-code>abstract class</el-code>),
<a href="#interface">interface</a>
<a href="#comment">#</a>
<!-- #endregion-->
<!--     #region Main method-->
<h3 id="main">Main method</h3>
<p>A file must have a <el-code>main</el-code> method if it is intended to be run as program. (You may however develop and test code that does not have a <el-code>main</el-code> method, either as a coding exercise or for subsequent use within another program).</p>
<p>The <el-code>main</el-code> method defines the start point when a program is run.</p>
<p>The <el-code>main</el-code> method does not have to be at the top of the file, but this is a good convention to follow.</p>
<p>There may not be more than one <el-code>main</el-code> method in a file &#8211; and the global selector (above) will not show the <el-code>main</el-code> option when one already exists in the file.</p>
<p>Example:</p>

<el-code-block>
<main class="multiline" id="main1" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>main</el-kw> <el-msg class="warning"></el-msg><el-fr>1</el-fr></el-top>
  <el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>[<el-lit>3</el-lit>, <el-lit>6</el-lit>, <el-lit>1</el-lit>, <el-lit>0</el-lit>, <el-lit>99</el-lit>, <el-lit>4</el-lit>, <el-lit>67</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>2</el-fr></el-statement>
  <el-statement class="warning" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>inPlaceRippleSort</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)<el-fr>3</el-fr></el-top></el-statement>
  <el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>4</el-fr></el-statement>
  <el-kw>end main</el-kw>
</main>
</el-code-block>

<p>The <el-code>main</el-code> method may delegate work to one or more <a href="#procedure">procedure</a> or <a href="#function">function</a>.</p>
<!-- #endregion-->
<!--     #region Procedure-->
 <h3 id="procedure">Procedure</h3>
<p id="Argument">A procedure is a named piece of behaviour that can define <b>parameters</b> which are given inputs via <b>arguments</b> in a <el-code>call()</el-code> statement.
Unlike a <a href="#function">function</a>, a procedure does not return a value.
  Also unlike a function, a procedure can have &#8216;side-effects&#8217;: indeed it <em>should</em> have side-effects, otherwise there would be no point in calling it!
  For this reason the statements within a procedure can:</p>
<li>Include <el-code>print</el-code> statements (or methods).</li>
<li>include <el-code>input</el-code> methods or other &#8216;system&#8217; methods (such as a random number generation).</li>
<li><el-code>call</el-code> other procedures (or itself if <a href="#Recursion">&#8216;recursion&#8217;</a> is required).</li>
<li>Re-assign a parameter, provided that parameter definition is preceded by the keyword <el-code>out</el-code> Example:</li>

<el-code-block>
  <el-proc class="ok multiline" id="proc11" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident13" class="ok" tabindex="0"><el-txt>inPlaceRippleSort</el-txt><el-place><i>name</i></el-place>></el-field></el-method>(<el-field id="params14" class="optional ok" tabindex="0"><el-txt><el-kw>out</el-kw> <el-id>arr</el-id> <el-kw>as</el-kw> <el-type>Array</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;</el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-msg></el-msg><el-fr>5</el-fr></el-top>
  <el-statement class="ok" id="var15" tabindex="0"><el-kw>variable </el-kw><el-field id="var16" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>6</el-fr></el-statement>
  <el-statement class="ok" id="var18" tabindex="0"><el-kw>variable </el-kw><el-field id="var19" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr20" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>length</el-method>() - <el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>7</el-fr></el-statement>
  <el-statement class="ok multiline" id="repeat21" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>repeat</el-kw></el-top><el-fr>8</el-fr>
  <el-statement class="ok" id="set24" tabindex="0"><el-kw>set </el-kw><el-field id="ident25" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr26" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>9</el-fr></el-statement>
  <el-statement class="ok multiline" id="for27" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident29" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr30" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr31" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr32" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>10</el-fr></el-top>
  <el-statement class="ok multiline" id="if33" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr35" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>[<el-id>i</el-id>] &gt; <el-id>arr</el-id>[<el-id>i</el-id> + <el-lit>1</el-lit>]</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw><el-fr>11</el-fr></el-top><el-msg></el-msg>
  <el-statement class="ok" id="let36" tabindex="0"><el-kw>let </el-kw><el-field id="var37" class="ok" tabindex="0"><el-txt><el-id>temp</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr38" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>[<el-id>i</el-id>]</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>12</el-fr></el-statement>
  <el-statement class="ok" id="call39" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident40" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>putAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args41" class="optional ok" tabindex="0"><el-txt><el-id>i</el-id>, <el-id>arr</el-id>[<el-id>i</el-id> + <el-lit>1</el-lit>]</el-txt><el-place><i>arguments</i></el-place></el-field>)<el-msg></el-msg><el-fr>13</el-fr></el-top></el-statement>
  <el-statement class="ok" id="call42" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident43" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>putAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args44" class="optional ok" tabindex="0"><el-txt><el-id>i</el-id> + <el-lit>1</el-lit>, <el-id>temp</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)<el-msg></el-msg><el-fr>14</el-fr></el-top></el-statement>
  <el-statement class="ok" id="set45" tabindex="0"><el-kw>set </el-kw><el-field id="ident46" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr47" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>15</el-fr></el-statement>
  <el-kw>end if</el-kw>
  </el-statement>
  <el-kw>end for</el-kw>
  </el-statement>
  <el-statement class="ok" id="set48" tabindex="0"><el-kw>set </el-kw><el-field id="ident49" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr50" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id> - <el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>16</el-fr></el-statement>
  <el-kw>end repeat when </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt><el-kw>not</el-kw> <el-id>changes</el-id></el-txt><el-place><i>condition</i></el-place></el-field>
  <el-msg></el-msg></el-statement>
  <el-kw>end procedure</el-kw>
  </el-proc>
</el-code-block>

<p>Procedures are executed within a <a href="#call">call</a> statement, for example:</p>
<el-code-block>
<main class="ok multiline" id="main1" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>main</el-kw><el-msg></el-msg><el-fr>1</el-fr></el-top>
  <el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>[<el-lit>3</el-lit>, <el-lit>6</el-lit>, <el-lit>1</el-lit>, <el-lit>0</el-lit>, <el-lit>99</el-lit>, <el-lit>4</el-lit>, <el-lit>67</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>2</el-fr></el-statement>
  <el-statement class="ok" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>inPlaceRippleSort</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)<el-msg></el-msg><el-fr>3</el-fr></el-top></el-statement>
  <el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>4</el-fr></el-statement>
  <el-kw>end main</el-kw>
</main>
</el-code-block>

<!-- #endregion-->
<!--     #region Function-->
<h3 id="function">Function</h3>

<p>A function is a named piece of behaviour that can define <b>parameters</b> which are given inputs via <b>arguments</b> when reference to the function occurs in a statement.
Unlike a <a href="#procedure">procedure</a>, a function returns a value. Also unlike a procedure, a function can have no &#8216;side-effects&#8217;.

<p>
TODO

<!-- #endregion-->
<!--     #region Parameters-->
<div id="as"></div>
<h4 id="Parameter">Parameters</h4>
Parameters for both procedures and functions are defined in exactly the same way: each parameter definition takes the form:
<br>&nbsp;&nbsp;&lt;name&gt; <el-code>as</el-code> &lt;Type&gt;
<br> for example:
<br>&nbsp;&nbsp;<el-code>age as Int</el-code>

<!-- #endregion--
<!--     #region Recursion-->
<h4 id="Recursion">Recursion</h4>
Procedures and functions may be called or referenced recursively. For example, a simple factorial calculation:
<el-code-block>
<el-func class="selected focused ok multiline" id="func11" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident13" class="ok" tabindex="0"><el-txt>factorial</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params14" class="optional ok" tabindex="0"><el-txt><el-id>n</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type15" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field><el-msg></el-msg><el-fr>3</el-fr></el-top>
<el-statement class="ok" id="return16" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>return </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt>(<el-kw>if </el-kw><el-id>n</el-id> &gt; <el-lit>1</el-lit><el-kw> then </el-kw><el-id>n</el-id>*<el-method>factorial</el-method>(<el-id>n</el-id> - <el-lit>1</el-lit>)<el-kw><br>else </el-kw><el-lit>1</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>4</el-fr></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<!-- #endregion-->
<!--     #region Test-->
<h3 id="test">Test</h3>

<p>Example of a Test:</p>
<el-code-block>
<el-test class="ok multiline" id="test74" tabindex="0" title="To ignore, select 'test' frame then Ctrl-i">
  <el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment76" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field><el-msg></el-msg><el-fr>26</el-fr></el-top>
  <el-statement class="ok" id="let77" tabindex="0"><el-kw>let </el-kw><el-field id="var78" class="ok" tabindex="0"><el-txt><el-id>li1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr79" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>", "<el-lit>lime</el-lit>", "<el-lit>orange</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>27</el-fr></el-statement>
  <el-statement class="ok" id="assert80" tabindex="0"><el-kw>assert </el-kw><el-field id="text81" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr82" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>28</el-fr></el-statement>
  <el-statement class="ok" id="assert83" tabindex="0"><el-kw>assert </el-kw><el-field id="text84" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>lime</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr85" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>29</el-fr></el-statement>
  <el-statement class="ok" id="assert86" tabindex="0"><el-kw>assert </el-kw><el-field id="text87" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>orange</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr88" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>30</el-fr></el-statement>
  <el-statement class="ok" id="assert89" tabindex="0"><el-kw>assert </el-kw><el-field id="text90" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr91" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>31</el-fr></el-statement>
  <el-statement class="ok" id="let92" tabindex="0"><el-kw>let </el-kw><el-field id="var93" class="ok" tabindex="0"><el-txt><el-id>li2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr94" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>", "<el-lit>orange</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>32</el-fr></el-statement>
  <el-statement class="ok" id="assert95" tabindex="0"><el-kw>assert </el-kw><el-field id="text96" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr97" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>33</el-fr></el-statement>
  <el-statement class="ok" id="assert98" tabindex="0"><el-kw>assert </el-kw><el-field id="text99" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>orange</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr100" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>34</el-fr></el-statement>
  <el-statement class="ok" id="assert101" tabindex="0"><el-kw>assert </el-kw><el-field id="text102" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr103" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>35</el-fr></el-statement>
  <el-statement class="ok" id="let104" tabindex="0"><el-kw>let </el-kw><el-field id="var105" class="ok" tabindex="0"><el-txt><el-id>li3</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr106" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>36</el-fr></el-statement>
  <el-statement class="ok" id="assert107" tabindex="0"><el-kw>assert </el-kw><el-field id="text108" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li3</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr109" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>37</el-fr></el-statement>
  <el-statement class="ok" id="assert110" tabindex="0"><el-kw>assert </el-kw><el-field id="text111" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li3</el-id>, "<el-lit>lime</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr112" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>38</el-fr></el-statement>
  <el-statement class="ok" id="let113" tabindex="0"><el-kw>let </el-kw><el-field id="var114" class="ok" tabindex="0"><el-txt><el-id>li4</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr115" class="ok" tabindex="0"><el-txt><el-kw>empty</el-kw> <el-type>Array</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>&gt;</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>39</el-fr></el-statement>
  <el-statement class="ok" id="assert116" tabindex="0"><el-kw>assert </el-kw><el-field id="text117" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li4</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr118" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>40</el-fr></el-statement>
  <el-kw>end test</el-kw>
  </el-test>
</el-code-block>

<b>Notes:</b>
<li>Elan tests are designed to test <el-code>function</el-code>s only. It is not possible to call a <el-code>procedure</el-code> or <el-code>main</el-code> routine within a test. Nor is it possible to use any <a href="#System_methods">System method</a> (the same rule as within a function).</li>
<li>A test may be given a name and/or description, which is free-form text, just like a comment. This name/description is optional and plays no role in the execution of the test. You might give the test the same name as a function that it is testing, or you might describe a particular scenario that is being tested.</li>
<li><el-code>test</el-code> methods may be written anywhere in the code, at the global (file) level. </li>
<li>A test method may contain multiple <el-code>assert</el-code> statements. When tests are run, the test runner (part of the Elan IDE) will attempt to run all <el-code>assert</el-code> statements and show the pass/fail outcome alongside each one. However, if the test hits a runtime error (as distinct from an <el-code>assert</el-code> failure) then execution of the test will stop and remaining <el-code>assert</el-code>s will be shown as &#8216;not run&#8217;.</li>
<li>In addition to <el-code>assert</el-code> statements, a <el-code>test</el-code> may contain any other statements that may be added into a <el-code>function</el-code> (except <el-code>return</el-code>).</li>
<li>All <el-code>assert</el-code>s should be at the top level within the <el-code>test</el-code> frame; none should be put into a loop structure.<a name="GoBack"></a></li>

<h4>Testing Float values</h3>
<p>When testing <el-code>Float</el-code> values it is recommend that you always use the <el-code>round</el-code> function to round the computed result to a fixed number of decimal places. This avoids rounding errors and is easier to read:</p>
<p><el-code-block>
<el-test class="ok multiline" id="test5" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment7" class="optional ok" tabindex="0"><el-txt>round()</el-txt><el-place><i>optional description</i></el-place></el-field><el-msg></el-msg><el-fr>1</el-fr></el-top>
<el-statement class="ok" id="assert8" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>assert </el-kw><el-field id="text9" class="ok" tabindex="0"><el-txt><el-method>sqrt</el-method>(<el-lit>2</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr10" class="ok" tabindex="0"><el-txt><el-lit><el-lit>1</el-lit>.414</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>2</el-fr></el-statement>
<el-kw>end test</el-kw>
</el-test>
<el-code-block>
</p>

<h4>Testing for runtime errors</h3>
<p>If the expression you are testing causes a runtime error then the error will be displayed in the red fail message:</p>
<p><el-code-block>
<el-test class="error multiline" id="test5" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment7" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field><el-msg></el-msg><el-fr>1</el-fr></el-top>
<el-statement class="ok" id="let62" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>let </el-kw><el-field id="var63" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr64" class="ok" tabindex="0"><el-txt>[<el-lit>5</el-lit>, <el-lit>1</el-lit>, <el-lit>7</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>2</el-fr></el-statement>
<el-statement class="ok" id="assert77" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>assert </el-kw><el-field id="text78" class="ok" tabindex="0"><el-txt><el-id>a</el-id>[<el-lit>0</el-lit>]</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr79" class="ok" tabindex="0"><el-txt><el-lit>5</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>3</el-fr></el-statement>
<el-statement class="ok" id="assert84" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>assert </el-kw><el-field id="text85" class="ok" tabindex="0"><el-txt><el-id>a</el-id>[<el-lit>2</el-lit>]</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr86" class="ok" tabindex="0"><el-txt><el-lit>7</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg><el-fr>4</el-fr></el-statement>
<el-statement class="ok" id="assert91" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>assert </el-kw><el-field id="text92" class="ok" tabindex="0"><el-txt><el-id>a</el-id>[<el-lit>3</el-lit>]</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr93" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="error">actual: Out of range index: 3 size: 3</el-msg><el-fr>5</el-fr></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block></p>
<p>If this occurs, mark the tests that you added since the last successful test run with <el-code>ignore</el-code> (see below), and then remove the <el-code>ignore</el-code>s one by one until the cause is identified and can be fixed.</p>

<h3>Marking a test with &#8216;ignore&#8217;</h3>
<p>It is possible to mark a test with the <el-code>ignore</el-code> keyword, by selecting the test frame and then hitting Ctrl-i for example:</p>
<p><el-code-block><el-test class="default multiline" id="test5" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu">
<el-top><el-expand>+</el-expand><el-kw style="background-color:yellow;">ignore</el-kw> <el-kw>test </el-kw><el-field id="comment7" class="optional ok" tabindex="0"><el-txt>clockTick</el-txt><el-place><i>optional description</i></el-place></el-field><el-msg></el-msg><el-fr>1</el-fr></el-top>
<el-statement class="ok" id="let170" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>let </el-kw><el-field id="var171" class="ok" tabindex="0"><el-txt><el-id>g1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr172" class="ok" tabindex="0"><el-txt><el-method>newGame</el-method>(<el-kw>new</el-kw> <el-type>Random</el-type>())</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>2</el-fr></el-statement>
<el-statement class="ok" id="let179" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>let </el-kw><el-field id="var180" class="ok" tabindex="0"><el-txt><el-id>g2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr181" class="ok" tabindex="0"><el-txt><el-method>newApple</el-method>(<el-id>g1</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>3</el-fr></el-statement>
<el-statement class="ok" id="let190" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>let </el-kw><el-field id="var191" class="ok" tabindex="0"><el-txt><el-id>g3</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr192" class="ok" tabindex="0"><el-txt><el-method>clockTick</el-method>(<el-id>g2</el-id>, "<el-lit>s</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>4</el-fr></el-statement>
<el-statement class="ok" id="assert203" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>assert </el-kw><el-field id="text204" class="ok" tabindex="0"><el-txt><el-id>g3</el-id>.<el-method>head</el-method>()</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr205" class="ok" tabindex="0"><el-txt><el-method>newSquare</el-method>(<el-lit>22</el-lit>, <el-lit>16</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field><el-msg></el-msg><el-fr>5</el-fr></el-statement>
<el-kw>end test</el-kw>
</el-test></el-code-block></p>
<p>When a test is marked with <el-code>ignore</el-code>, that test will not be executed when the tests are run, and its result will be shown as &#8216;not run&#8217;. The overall test status will also show in the &#8216;warning&#8217; status (amber colour), even if all the tests that did run passed. This is to discourage you from leaving a test marked <el-code>ignore</el-code> for long. </p>
<p>The principal reason for marking a test <el-code>ignore</el-code> is when either the test code or code in any function being called, would not terminate. This typically means that there is a loop (or a recursive call) with no exit condition, or where the exit condition is never met. </p>
<p>If you do create such code without realising it, then when the tests are executed the test runner will &#8216;time out&#8217; after a few seconds (most tests will pass in milliseconds), and an error message will be shown on the Console. The test that caused the time-out will automatically then be marked <el-code>ignore</el-code>. Your priority should then be to identify the cause of the time-out and attempt to fix it before then restoring the test by selecting the test frame and hitting <el-code>Ctrl-i</el-code>, which is a toggle for setting and unsetting an <el-code>ignore</el-code> status)</p>
<!-- #endregion-->
<!--     #region Constant-->
<h3 id="constant">Constant</h3>
<p>A <el-code>constant</el-code> defines a named value that cannot change.</p>
<p>A <el-code>constant</el-code> is always defined at &#8216;global&#8217; level (directly within a file) and is global in scope. A <el-code>constant</el-code> may not be defined within any method. (However, see [missing hyperlink]).</p>
<p>The name of a <el-code>constant</el-code> follows the rules for an <a href="#Identifier">Identifier</a>.</p>
<p>The value to which a constant is set must be a <span class="Link">Literal value</span>, of one of the following Types: <span class="Link">Int</span>, <span class="Link">Float</span>, <span class="Link">Boolean</span>, <span class="Link">String</span>, <a href="#Dictionary">Dictionary</a>, or <a href="#DictionaryImmutable">DictionaryImmutable.</a></p>
<p>Examples:</p>

<el-code-block>
<el-const class="ok multiline" id="const1" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident2" class="ok" tabindex="0"><el-txt><el-id>phi</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text3" class="ok" tabindex="0"><el-txt><el-lit><el-lit>1</el-lit>.618</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field><el-msg></el-msg><el-fr>1</el-fr></el-const>
  <el-const class="ok multiline" id="const4" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident5" class="ok" tabindex="0"><el-txt><el-id>maxHits</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text6" class="ok" tabindex="0"><el-txt><el-lit>10</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field><el-msg></el-msg><el-fr>2</el-fr></el-const>
  <el-const class="ok multiline" id="const7" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident8" class="ok" tabindex="0"><el-txt><el-id>warningMsg</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text9" class="ok" tabindex="0"><el-txt>"<el-lit>Limit reached</el-lit>"</el-txt><el-place><i>literal value or data structure</i></el-place></el-field><el-msg></el-msg><el-fr>3</el-fr></el-const>
  <el-const class="ok multiline" id="const10" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident11" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text12" class="ok" tabindex="0"><el-txt>{"<el-lit>apple</el-lit>", "<el-lit>orange</el-lit>", "<el-lit>banana</el-lit>"}</el-txt><el-place><i>literal value or data structure</i></el-place></el-field><el-msg></el-msg><el-fr>4</el-fr></el-const>
  <el-const class="ok multiline" id="const13" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident14" class="ok" tabindex="0"><el-txt><el-id>black</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text15" class="ok" tabindex="0"><el-txt><el-lit>0x000000</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field><el-msg></el-msg><el-fr>5</el-fr></el-const>
  <el-const class="ok multiline" id="const16" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident17" class="ok" tabindex="0"><el-txt><el-id>red</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text18" class="ok" tabindex="0"><el-txt><el-lit>0xff0000</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field><el-msg></el-msg><el-fr>6</el-fr></el-const>
  <el-const class="ok multiline" id="const19" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident20" class="ok" tabindex="0"><el-txt><el-id>scrabbleValues</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text21" class="ok" tabindex="0"><el-txt>{"<el-lit>A</el-lit>":<el-lit>1</el-lit>, "<el-lit>B</el-lit>":<el-lit>3</el-lit>, "<el-lit>C</el-lit>":<el-lit>3</el-lit>, "<el-lit>D</el-lit>":<el-lit>2</el-lit>, "<el-lit>E</el-lit>":<el-lit>1</el-lit>, "<el-lit>F</el-lit>":<el-lit>4</el-lit>, "<el-lit>G</el-lit>":<el-lit>2</el-lit>, "<el-lit>H</el-lit>":<el-lit>4</el-lit>, "<el-lit>I</el-lit>":<el-lit>1</el-lit>, "<el-lit>J</el-lit>":<el-lit>8</el-lit>, "<el-lit>K</el-lit>":<el-lit>5</el-lit>, "<el-lit>L</el-lit>":<el-lit>1</el-lit>, "<el-lit>M</el-lit>":<el-lit>3</el-lit>, "<el-lit>N</el-lit>":<el-lit>1</el-lit>, "<el-lit>O</el-lit>":<el-lit>1</el-lit>, "<el-lit>P</el-lit>":<el-lit>3</el-lit>, "<el-lit>Q</el-lit>":<el-lit>10</el-lit>, "<el-lit>R</el-lit>":<el-lit>1</el-lit>, "<el-lit>S</el-lit>":<el-lit>1</el-lit>, "<el-lit>T</el-lit>":<el-lit>1</el-lit>, "<el-lit>U</el-lit>":<el-lit>1</el-lit>, "<el-lit>V</el-lit>":<el-lit>4</el-lit>, "<el-lit>W</el-lit>":<el-lit>4</el-lit>, "<el-lit>X</el-lit>":<el-lit>8</el-lit>, "<el-lit>Y</el-lit>":<el-lit>4</el-lit>, "<el-lit>Z</el-lit>":<el-lit>10</el-lit>}</el-txt><el-place><i>literal value or data structure</i></el-place></el-field><el-msg></el-msg><el-fr>7</el-fr></el-const>
  <el-const class="focused multiline" id="const22" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident23" class="ok" tabindex="0"><el-txt><el-id>colours</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text24" class="" tabindex="0"><el-txt>{<el-type>Suit</el-type>.<el-id>clubs</el-id>:<el-id>black</el-id>, <el-type>Suit</el-type>.<el-id>diamonds</el-id>:<el-id>red</el-id>, <el-type>Suit</el-type>.<el-id>hearts</el-id>:<el-id>red</el-id>, <el-type>Suit</el-type>.<el-id>spades</el-id>:<el-id>black</el-id>}</el-txt><el-place><i>literal value or data structure</i></el-place></el-field> <el-msg class="warning"></el-msg><el-fr>8</el-fr></el-const></div>
</el-code-block>
<p>(In the last example above, <el-code>Suit</el-code> is an <a href="#Enum_1">Enum</a>).</p>

<h3 id="enum">Enum</h3>
<p>An <el-code>enum</el-code> &#8211; short for &#8216; 'enumeration' &#8217; &#8211; is the simplest form of &#8216;user-defined Type&#8217;.
It specifies a set of values, each of which is defined as a name, such that a named value of that enum Type must always hold one of those values.</p>

<h4>Examples:</h4>
<el-code-block>
  <el-enum class="selected focused ok multiline" id="enum773" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type774" class="ok" tabindex="0"><el-txt><el-type>Action</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals775" class="ok" tabindex="0"><el-txt><el-id>stand</el-id>, <el-id>draw</el-id></el-txt><el-place><i>values</i></el-place></el-field><el-msg></el-msg><el-fr>245</el-fr></el-enum>
  <el-enum class="ok multiline" id="enum776" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type777" class="ok" tabindex="0"><el-txt><el-type>Outcome</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals778" class="ok" tabindex="0"><el-txt><el-id>undecided</el-id>, <el-id>lose</el-id>, <el-id>draw</el-id>, <el-id>win</el-id>, <el-id>winDouble</el-id></el-txt><el-place><i>values</i></el-place></el-field><el-msg></el-msg><el-fr>246</el-fr></el-enum>
  <el-enum class="ok multiline" id="enum779" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type780" class="ok" tabindex="0"><el-txt><el-type>Status</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals781" class="ok" tabindex="0"><el-txt><el-id>pending</el-id>, <el-id>playing</el-id>, <el-id>standing</el-id>, <el-id>blackjack</el-id>, <el-id>bust</el-id></el-txt><el-place><i>values</i></el-place></el-field><el-msg></el-msg><el-fr>247</el-fr></el-enum>
</el-code-block>

<h4>Type name</h4>
<p>The name given to an <el-code>enum</el-code> (see below), which must begin with an upper-case letter, is used as the Type name when passing a value to or from a procedure or function. </p>

<h4>Using an enum</h4>
<p>The value is specified by the Type name for the specified <el-code>enum</el-code>, followed by a dot and the value name, for example:</p>
<el-code>variable x set to Status.ready</el-code><br>

<h4>Notes</h4>
<li><el-code>enum</el-code>s are read-only: once they have been defined it is not possible to add, remove, or update their values.</li>
<!-- #endregion-->
<!--     #region Record-->
<h3 id="record">Record</h3>

<p>A <el-code><el-kw>record</el-kw></el-code> is a user-defined data structure that is given a Type name &#8211;  (which must begin with an upper-case letter).
  The record defines one or more properties, each of which has a name (starting with a lower-case letter) and a Type.
  The Type of a property may be any simple value Type (as in the example above), or a data structure such ,
  another Type of <el-code><el-kw>record</el-kw></el-code> (or even the same Type of record).</p>

  <p>Note that a <el-code><el-kw>record</el-kw></el-code> Type has some similarity to a <a href="#class">class</a>:</p>
  <li>Both are user-define data structures</li>
  <li>Both are given a &#8216;Type name&#8217;</li>
  <li>Both may define one or more properties, each with a name and Type</li>
  <li>Both may define encapsulated methods</li>
  <p>However a <el-code><el-kw>record</el-kw></el-code> is different from a <el-code>class</el-code> in that:</p>
  <li>A <el-code><el-kw>record</el-kw></el-code> is immutable (like a <el-code>List</el-code> or a <el-code>String</el-code>). You can create a copy with specified differences but you cannot modify a <el-code><el-kw>property</el-kw></el-code> on a given instance.</li>
  <li>A <el-code><el-kw>record</el-kw></el-code> instance may be created or copied using a <el-code>with</el-code> clause, whereas <el-code>with</el-code> may not be used on a class instance.</li>
  <li>A <el-code><el-kw>record</el-kw></el-code> does not define a constructor</li>
  <li>A <el-code><el-kw>record</el-kw></el-code> may define only <i>function</i> methods - because <i>procedure</i> methods would imply the ability to <i>mutate</i> the record.</li>
<h4>Examples:</h4>
<el-code-block>
  <el-class class="selected focused ok multiline" id="class12" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu">
    <el-top><el-expand>+</el-expand><el-kw>record </el-kw><el-field id="type13" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place>Name</el-place></el-field><el-msg></el-msg><el-fr>5</el-fr></el-top>
    <el-prop class="ok" id="prop16" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>property </el-kw><el-field id="ident17" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type18" class="ok" tabindex="0"><el-txt><el-type>Float</el-type></el-txt><el-place><i>Type</i></el-place></el-field><el-msg></el-msg><el-fr>6</el-fr></el-prop>
    <el-prop class="ok" id="prop19" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>property </el-kw><el-field id="ident20" class="ok" tabindex="0"><el-txt><el-id>y</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type21" class="ok" tabindex="0"><el-txt><el-type>Float</el-type></el-txt><el-place><i>Type</i></el-place></el-field><el-msg></el-msg><el-fr>7</el-fr></el-prop>
    <el-func class="ok multiline" id="func22" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu">
    <el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident24" class="ok" tabindex="0"><el-txt>asString</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params25" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type26" class="ok" tabindex="0"><el-txt><el-type>String</el-type></el-txt><el-place><i>Type</i></el-place></el-field><el-msg></el-msg><el-fr>8</el-fr></el-top>
    <el-statement class="ok" id="return27" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>return </el-kw><el-field id="expr28" class="ok" tabindex="0"><el-txt>"<el-lit>Sq </el-lit>{<el-kw>property</el-kw>.<el-id>x</el-id>}<el-lit>, </el-lit>{<el-kw>property</el-kw>.<el-id>y</el-id>}<el-lit></el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>9</el-fr></el-statement>
    <el-kw>end function</el-kw>
    </el-func>
    <el-kw>end record</el-kw>
  </el-class>
</el-code-block>
<el-code-block><el-class class="error multiline" id="class1" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu">
<el-top><el-expand>+</el-expand><el-kw>record </el-kw><el-field id="type2" class="ok" tabindex="0"><el-txt><el-type>Game</el-type></el-txt><el-place>Name</el-place></el-field> <el-msg class="error"></el-msg><el-fr>1</el-fr></el-top>
<el-prop class="ok" id="prop9" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>property </el-kw><el-field id="ident10" class="ok" tabindex="0"><el-txt><el-id>head</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type11" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field><el-msg></el-msg><el-fr>2</el-fr></el-prop>
<el-prop class="ok" id="prop18" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>property </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-id>body</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type20" class="ok" tabindex="0"><el-txt><el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Sqaure</el-type>&gt;</el-txt><el-place><i>Type</i></el-place></el-field><el-msg></el-msg><el-fr>3</el-fr></el-prop>
<el-prop class="ok" id="prop27" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>property </el-kw><el-field id="ident28" class="ok" tabindex="0"><el-txt><el-id>priorTail</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type29" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field><el-msg></el-msg><el-fr>4</el-fr></el-prop>
<el-prop class="error" id="prop34" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>property </el-kw><el-field id="ident35" class="ok" tabindex="0"><el-txt><el-id>apple</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type36" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field> <el-fr>5</el-fr></el-prop>
<el-prop class="error" id="prop43" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>property </el-kw><el-field id="ident44" class="ok" tabindex="0"><el-txt><el-id>apple</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type45" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field> <el-fr>6</el-fr></el-prop>
<el-prop class="ok" id="prop48" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>property </el-kw><el-field id="ident49" class="ok" tabindex="0"><el-txt><el-id>isOn</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type50" class="ok" tabindex="0"><el-txt><el-type>Boolean</el-type></el-txt><el-place><i>Type</i></el-place></el-field><el-msg></el-msg><el-fr>7</el-fr></el-prop>
<el-prop class="ok" id="prop55" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>property </el-kw><el-field id="ident56" class="ok" tabindex="0"><el-txt><el-id>rnd</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type57" class="ok" tabindex="0"><el-txt><el-type>Random</el-type></el-txt><el-place><i>Type</i></el-place></el-field><el-msg></el-msg><el-fr>8</el-fr></el-prop>
<el-prop class="ok" id="prop64" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>property </el-kw><el-field id="ident65" class="ok" tabindex="0"><el-txt><el-id>graphics</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type66" class="ok" tabindex="0"><el-txt><el-type>BlockGraphics</el-type></el-txt><el-place><i>Type</i></el-place></el-field><el-msg></el-msg><el-fr>9</el-fr></el-prop>
<el-prop class="ok" id="prop73" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>property </el-kw><el-field id="ident74" class="ok" tabindex="0"><el-txt><el-id>key</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type75" class="ok" tabindex="0"><el-txt><el-type>String</el-type></el-txt><el-place><i>Type</i></el-place></el-field><el-msg></el-msg><el-fr>10</el-fr></el-prop>
<el-kw>end record</el-kw>
</el-class>
</el-code-block>
  <p>Having defined a record Type, such as <el-code>Game</el-code> above, you can create as many instances as you wish using the following syntax to specify the values:</p>
<el-code-block>
  <el-statement class="ok" id="let597" tabindex="0"><el-kw>let </el-kw><el-field id="var598" class="ok" tabindex="0"><el-txt><el-id>g1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr599" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Game</el-type>()<el-kw> with </el-kw><br><el-id>head</el-id><el-kw> set to </el-kw><el-method>newSquare</el-method>(<el-lit>22</el-lit>, <el-lit>15</el-lit>), <br><el-id>key</el-id><el-kw> set to </el-kw>"<el-lit>d</el-lit>", <br><el-id>isOn</el-id><el-kw> set to </el-kw><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>52</el-fr></el-statement>
</el-code-block>
<p>
Note that you are <em>not required</em> to provide a value for each property because, where a property is not specified in the &#8216;<el-code>with</el-code> clause&#8217; (as above), that property will be given the empty (default) value of the correct Type.</p>
<p>You can then read the values from the properties using &#8216;dot syntax&#8217; for example:</p>
<el-code-block><el-statement class="" id="print15" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>print </el-kw><el-field id="expr16" class="optional" tabindex="0"><el-txt><el-id>sq</el-id>.<el-id>size</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg><el-fr>2</el-fr></el-statement></el-code-block>
<p>
<p><el-code><el-kw>record</el-kw></el-code> Types are immutable: the properties on an instance may not be changed, directly.
  However, you can easily create another instance that is a copy of the original,
  with all the same property values except for any specific changes made in another <el-code>with</el-code> clause.
  The newly-minted copy (with changes) must be assigned to a new named value. For example:</p>
<el-code-block>
  <el-statement class="" id="let3" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>sq1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>()<el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.5</el-lit>, <br><el-id>y</el-id><el-kw> set to </el-kw><el-lit><el-lit>4</el-lit>.0</el-lit>, <br><el-id>size</el-id><el-kw> set to </el-kw><el-lit><el-lit>1</el-lit>.0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="error"></el-msg><el-fr>2</el-fr></el-statement>
</el-code-block>
<el-code-block>
  <el-statement class="" id="let10" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>sq2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>sq1</el-id><el-kw> with </el-kw><br><el-id>size</el-id><el-kw> set to </el-kw><el-lit><el-lit>2</el-lit>.0</el-lit>, <br><el-id>colour</el-id><el-kw> set to </el-kw><el-id>red</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg><el-fr>4</el-fr></el-statement>
</el-code-block>
Or even to the same name if that name is a variable:</p>
<el-code-block>
  <el-statement class="ok" id="var3" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>()<el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.5</el-lit>, <br><el-id>y</el-id><el-kw> set to </el-kw><el-lit><el-lit>4</el-lit>.0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>2</el-fr></el-statement>
</el-code-block>
<el-code-block>
  <el-statement class="ok" id="set6" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>set </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>a</el-id><el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.7</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>3</el-fr></el-statement>
</el-code-block>

<p>This last example shows how you enter the comma-separated <el-code>with</el-code> clauses. The earlier examples show how the Editor displays a set of <el-code>with</el-code> clauses.</p>

<p>If you want to use one or more existing property values in order to determine a new value, the property name(s) must
  be prefixed with the name of the instance being copied, for example:</p>
<el-code-block>
  <el-statement class="" id="let9" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>let </el-kw><el-field id="var10" class="ok" tabindex="0"><el-txt><el-id>sq2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr11" class="" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>sq1</el-id><el-kw> with </el-kw><br><el-id>size</el-id><el-kw> set to </el-kw><el-id>sq1</el-id>.<el-id>size</el-id> + <el-lit>3</el-lit></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class=""></el-msg><el-fr>4</el-fr></el-statement>
</el-code-block>
</p>

<h4>Record deconstruction</h4>
<p>A record may be &#8216;deconstructed&#8217;, meaning that its properties are read into separate variables using the same syntax as for deconstructing a <span class="Link">Tuple</span>. For example, assuming that Square is a record defined as in the example above then this code:</p>
<el-code-block>
  <el-statement class="" id="let3" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>x</el-id>, <el-id>y</el-id>, <el-id>size</el-id>, <el-id>colour</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="" tabindex="0"><el-txt><el-id>mySquare</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg><el-fr>2</el-fr></el-statement>
</el-code-block>

<p>will read the <el-code>properties</el-code> into the four names defined.</p>
<p>Note</p>
<li>When deconstructing, the names of the values must match the names of the <el-code>properties</el-code> of the <el-code><el-kw>record</el-kw></el-code>. However, the ordering of the names does not have to match the order in which the <el-code>properties</el-code> are defined in the <el-code><el-kw>record</el-kw></el-code>.</li>
<!-- #endregion-->
<!--     #region Class-->
<h3 id="class">Class</h3>

<p>See also: <a href="inherits">Inheritance</a></p>

<p>A <el-code>class</el-code> is a user-defined Type offering far richer capability than an <el-code>enum</el-code>. </p>
<p>(A <el-code><el-kw>record</el-kw></el-code> is in some ways similar to a <el-code>class</el-code> but simpler: it defines properties, but has no constructor and no methods. See <span class="Link">Working with records</span>).</p>

<h3>Definition</h3>
<p>Here is an example of <el-code>class</el-code> definition, taken from the Snake OOP demo program:</p>
<el-code>class Apple</el-code><br>
<el-code>  constructor(board as Board)</el-code><br>
<el-code>    set property.board to board</el-code><br>
<el-code>  end constructor</el-code><br>

<el-code>  property board as Board</el-code><br>

<el-code>  property location as Square</el-code><br>

<el-code>  procedure newRandomPosition(snake as Snake)</el-code><br>
<el-code>    repeat</el-code><br>
<el-code>      variable ranX set to randomInt(0, board.width - 1)</el-code><br>
<el-code>      variable ranY set to randomInt(0, board.height - 1)</el-code><br>
<el-code>      set location to new Square(ranX, ranY)</el-code><br>
<el-code>    end repeat when not snake.bodyCovers(location)</el-code><br>
<el-code>  end procedure</el-code><br>

<el-code>  function updateGraphics(gr as BlockGraphics) returns BlockGraphics</el-code><br>
<el-code>    return gr.withBlock(location.x, location.y, red)</el-code><br>
<el-code>  end function</el-code><br>
<el-code>end class</el-code><br>

<p>Notes</p>
<p>A <el-code>class</el-code> must have:</p>
<li>A name that, like any other Type, must begin with an upper-case letter.</li>
<p>A class may define:</p>
<li>One or more properties &#8211; see <a href="#property">Property</a></li>
<li><el-code>function</el-code> methods &#8211; see <span class="Link">Function method</span></li>
<li><el-code>procedure</el-code> methods &#8211; see <span class="Link">Procedure method</span></li>
<li>A <el-code>constructor</el-code> which may be used for setting up the values of properties. The <el-code>constructor</el-code> may optionally define parameters to force the calling code to provide initial values. However, it is not necessary to add a <el-code>constructor</el-code> if you have no need to initialise properties. Code in the constructor may make use of any functions, and follows the same constraints as a <el-code>function</el-code> (i.e. may not call any <el-code>procedure</el-code>, whether defined on the <el-code>class</el-code> or outside).</li>

<h3>Using a class</h3>
<p>A <el-code>class</el-code> is instantiated using the keyword new followed by the class name and brackets, which should enclose the comma-separated arguments required to match the parameters (if any) defined on the constructor for that <el-code>class</el-code>. For example (also from the Snake OOP demo):</p>
<el-code>  variable board set to new Board(40, 30)</el-code><br>
<el-code>  variable currentDirection set to Direction.up</el-code><br>
<el-code>  variable snake set to new Snake(board, currentDirection)</el-code><br>
<el-code>  variable apple set to new Apple(board)</el-code><br>

<p>The created instance may then be used within expressions, like any other variable.</p>

<h3 id="inherits">Inheritance</h2>
  <p>An ordinary <a href="class">class</a> (also known as a 'concrete class') may optionally inherit from just one <a href="Abstract_class">abstract class</a>
    but may additionally inherit from any number of <a href="interface">interfaces</a>.
    The concrete class must define for itself a concrete implementation of every <em>abstract</em> member defined in the <el-code>abstract class</el-code> or any <el-code>interface</el-code>s that it inherits from, directly or indirectly.</p>
  <p>Notes</p>
  <li>An <el-code>abstract class</el-code> must be declared above any class that inherits from it. This is the only case where the order of definition (of global constructs) matters.</li>
  <li>The <el-code>abstract class</el-code> (if any) and the interfaces (if any) that a concrete <el-code>class</el-code> inherits from may not contain duplicates of any <el-code>abstract</el-code> member. Any duplicated definitions in the hierarchy will result in a compile error. If such duplications arise, you should factor out the common member definitions, and move them up the hierarchy or into new <el-code>interface</el-code>s inherited by the<el-code> interface</el-code>s and/or classes that need them.</li>
  <li>Also, inheritance hierarchies must form a tree, that is you must avoid creating a &#8216;circular dependency where, for example, Type <el-code>A</el-code> inherits from Type <el-code>B</el-code>, which inherits from Type<el-code> C</el-code>, which inherits from Type <el-code>A</el-code>.</li>
  <li>The various &#8216;super-Types&#8217; (<el-code>abstract class</el-code> and/or <el-code>interface</el-code>s) that a concrete <el-code>class</el-code> inherits from may not define conflicting members, e.g. members with the same name but having different Type signatures.</li>
<!-- #endregion-->
<!--     #region Abstract Class-->
<h3 id="Abstract_class">Abstract Class</h3>
<p>See also: <a href="inherits">Inheritance</a></p>
<p>An <el-code>abstract class</el-code> may not be instantiated (and hence may not define a constructor). It may define concrete members i.e.:</p>
<li>a <el-code><el-kw>property</el-kw></el-code> </li>
<li>a <el-code>function</el-code></li>
<li>a <el-code>procedure</el-code></li>
<p>As with a concrete class, any of these members may be made <el-code>private</el-code> after the corresponding frame has been added, by selecting that member frame and pressing Ctrl_p.</p>
<p>These concrete members are automatically inherited by any subclass, but they may not be overridden (re-defined) by the subclass. Therefore you should define concrete members only if they are intended to work identically on every subclass.</p>
<p id="Abstract_function" id="Abstract_procedure" id="Abstract_property">You may also define abstract methods on an abstract classes i.e. <el-code>abstract property</el-code>, <el-code>abstract function</el-code>, <el-code>abstract procedure</el-code>. Such methods define only the signature of the method, not the implementation (body). Therefore they have no <el-code>end</el-code> statement. For example:</p>
<el-code>abstract function calculateDiscount() as Float</el-code><br>
<p>
<br>
If you wish to have several subclasses of an <el-code>abstract class</el-code> that share a common implementation for a method, but require that some of the subclasses can define a different implementation, then you should:</p>
<li>Define the method as <el-code>abstract</el-code> on the superclass</li>
<li>Define a concrete implementation on the superclass with a similar, but slightly different name e.g. having a prefix such as: <el-code>default</el-code> </li>
<li>Each subclass must then define its implementation of the abstract method, but the ones needing a common implementation can be just one line, delegating responsibility up to the &#8216;default&#8217; method on the superclass. </li>
<!-- #endregion-->
<!--     #region Interface-->
<h3 id="interface">Interface</h3>
<p>See also: <a href="inherits">Inheritance</a></p>
<p>An <el-code>interface</el-code> is similar to an <el-code>abstract class</el-code>, with the difference that it may define only abstract members. The advantage of using an <el-code>interface</el-code> instead of an <el-code>abstract class</el-code> is that a concrete<el-code> class</el-code> can inherit from multiple <el-code>interface</el-code>s. See <span class="Link">Inheritance</span>.</p>
<p>An <el-code>interface</el-code> may inherit only from other <el-code>interface</el-code>s.</p>
<p>Important: An <el-code>interface</el-code> must not re-declare abstract interfaces that are defined in any <el-code>interface</el-code> it inherits from, directly or indirectly.</p>
<!-- #endregion -->
 <!-- #endregion -->
<!--   #region Member Instructions-->
<!--     #region Heading & Intro-->
<h2 id="Member">Member Instructions</h2>
<p>When you navigate to a <el-code>new code</el-code> that is at <em>member</em> level
  (located directly within a <a href="#record">record</a>, <a href="#class">class</a>, <a href="#abstract_class">abstract class</a>, or <a href="#interface">interface</a>)
  you will be shown the set of statements that may be inserted there, for example:</p>

  <el-code><el-member class="selected focused ok empty" id="select8" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-select><el-txt></el-txt><el-place>new code</el-place><el-help class="selector"> constructor function procedure property private...   #</el-help></el-select></el-member></el-code>

  <p>The specific members offered will depend upon the context, and/or upon your user profile.
    The full set of entries is shown here, with links to explanations below:</p>

    <a href="#constructor">constructor</a>,
    <a href="#property">property</a>,
    <a href="#procedure">procedure</a>,
    <a href="#function">function</a>,
    <a href="#abstract_property">abstract property</a>,
    <a href="#abstract_procedure">abstract procedure</a>,
    <a href="#abstract_function">abstract function</a>,
    <a href="#property">private property</a>,
    <a href="#procedure">private procedure</a>,
    <a href="#function">private function</a>,
    <a href="#comment">#</a>
<!-- #endregion-->
<!--     #region Constructor-->
<h3 id="constructor">Constructor</h3>
<p>A concrete class <em>may</em> define a single <el-code>constructor</el-code>, which may:</el-code></p>
<li>initialise any properties with fixed values</li>
<li>define one or more parameters, which are then used to initialise properties</li>
<p>If a class does define a constructor, and the constructor defines any parameters, then when the class is instantiated (using <el-code>new</el-code>) then values of
the correct types must be provided, for example, if the class <el-code><el-type>Snake</el-type></el-code> defines this constructor:</thead></p>

<el-code-block>
  <el-constructor class="ok multiline" id="constructor211" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>constructor</el-kw>(<el-field id="params213" class="optional ok" tabindex="0"><el-txt><el-id>x</el-id> <el-kw>as</el-kw> <el-type>Int</el-type>, <el-id>y</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-msg></el-msg><el-fr>67</el-fr></el-top>
    <el-statement class="ok" id="set214" tabindex="0"><el-kw>set </el-kw><el-field id="ident215" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>x</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr216" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>68</el-fr></el-statement>
    <el-statement class="ok" id="set217" tabindex="0"><el-kw>set </el-kw><el-field id="ident218" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>y</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr219" class="ok" tabindex="0"><el-txt><el-id>y</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>69</el-fr></el-statement>
    <el-kw>end constructor</el-kw>
  </el-constructor>
</el-code-block>

<p>then it may be instantiated like this:</p>

<el-code>
<el-statement class="selected focused ok" id="let44" tabindex="0"><el-kw>let </el-kw><el-field id="var45" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr46" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-lit>20</el-lit>, <el-lit>15</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field><el-msg></el-msg><el-fr>15</el-fr></el-statement>
</el-code>
<!-- #endregion-->
<!--     #region Property-->
<h3 id="property">Property</h3>
<p>Examples:</p>
<el-code>property height as Int</el-code><br>
<el-code>property board as Board</el-code><br>
<el-code>property head as Square</el-code><br>
<el-code>property body as [Square]</el-code><br>

<li>A <el-code><el-kw>property</el-kw></el-code> is defined on a <span class="Link">Class</span> and must <el-code>specify</el-code> a name (conforming to the rules for an <a href="#Identifier">Identifier</a> and a Type.</li>
<li>A <el-code><el-kw>property</el-kw></el-code> may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and pressing Ctrl-p. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
<li>If not marked <el-code>private</el-code>, a property may be read but not be written to. Properties may only be modified from outside the class by means of a <span class="Link">Procedure method</span>.</li>
<li>A property may be given an initial value in the <el-code>constructor</el-code>.</li>
<p>
If the <el-code><el-kw>property</el-kw></el-code> is not initialised within the constructor then it will automatically be given the <el-code>empty</el-code> value for that Type. You may test whether a property contains this default value by writing e.g.:<br>
<el-code>if head is empty Square</el-code></p>
<li>Whenever you wish to access a property from within a method (or from within the constructor) on the same class, then the name of the property must be prefixed with the &#8216;qualifier&#8217;: <el-code>property. </el-code>(&#8216;property-dot&#8217;). This applies whether you are reading or setting the property. By this means you can have a method parameter with the same name as a property, but they are unambiguous, because the property must be prefixed. A common pattern is to use the same name in a &#8216;setter&#8217; method, for example:</li>
<el-code>constructor(board as Board)</el-code><br>
<el-code>  set property.board to board</el-code><br>
<el-code>end constructor</el-code><br>
<br>
<el-code>procedure setHeight(height as Int)</el-code><br>
<el-code>  set property.height to height</el-code><br>
<el-code>end procedure</el-code><br>
<!-- #endregion-->
<!--     #region Procedure Method-->
<h3 id="procedure_method">Procedure Method</h3>
<p>A &#8216;procedure method&#8217; follows the same syntax and rules as a global <a href="procedure">procedure</a>. The differences are:</p>
<li>A procedure method, like a function method, is always referenced (used) by code outside the class using &#8216;dot syntax&#8217; on an instance.</li>
<li>A procedure method may read, or write to, any <el-code><el-kw>property</el-kw></el-code> defined on the class.</li>
<li>A procedure method may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and then pressing Ctrl-p. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
<!-- #endregion-->
<!--     #region Function Method-->
<h3 id="function_method">Function Method</h3>
<p>A function method follows the same syntax and rules as a global <a href="function">function</a>>. The differences are:</p>
<li>A <el-code>function</el-code> method is always referenced (used) by code outside the class using &#8216;dot syntax&#8217; on an instance.</li>
<li>A <el-code>function</el-code> method may directly reference (read only) any <el-code><el-kw>property</el-kw></el-code> defined on the class as though it were a variable/parameter.</li>
<li>A <el-code>function</el-code> method may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and then pressing Ctrl-p. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
<li>asString() method</li>
<li>asString method. This is just a regular function method with a specific name, no parameters and returning a String. If defined for a class, then if an instance of the class is printed, the <el-code>asString</el-code> function method will automatically be used. Typically <el-code>asString</el-code> will return a string made up of one or more of the property values, perhaps with additional text, or the results of function calls.</li>
<!-- #endregion-->
<!--     #region Abstract Property-->
<h3 id="Abstract_property">Abstract Property</h3>
TODO
<!-- #endregion-->
<!--     #region Abstract Procedure Method-->
<h3 id="Abstract_procedure_method">Abstract Procedure Method</h3>
TODO
<!-- #endregion-->
<!--     #region Abstract Function Method-->
<h3 id="abstract_function_method">Abstract Function Method</h3>
TODO
<!-- #endregion-->
<!--     #endregion -->
<!--   #region Statement Instructions-->
<!--     #region Heading & Intro-->
<h2 id="Statement">Statement Instructions</h2>
<p>When you navigate to a <el-code>new code</el-code> that is at <em>statement</em> level
  (located within a <a href="#Global">global</a> or a <a href="#Member">member</a> instruction)
  you will be shown the set of statements that may be inserted there, for example:</p>

  <el-code><el-statement class="selected focused ok empty" id="select4" tabindex="0" title="Right-mouse-click or Ctrl-m to show context menu"><el-select><el-txt></el-txt><el-place>new code</el-place><el-help class="selector"> call each for if let print repeat set throw try variable while #</el-help></el-select></el-statement></el-code>

  <p>The specific statements offered will depend upon the context, and/or upon your user profile.
    The full set of entries is shown here, with links to explanations below:</p>

<a href="#assert">assert</a>
<a href="#call">call</a>
<a href="#each">each</a>
<a href="#else">else</a>
<a href="#for">for</a>
<a href="#if">if</a>
<a href="#let">let</a>
<a href="#print">print</a>
<a href="#repeat">repeat</a>
<a href="#set">set</a>
<a href="#throw">throw</a>
<a href="#try">try</a>
<a href="#variable">variable</a>
<a href="#while">while</a>
<a href="#comment">#</a>
<!--     #endregion-->
<!--     #region Assert statement-->
<h3 id="assert">Assert statement</h3>
<!--     #endregion-->
<!--     #region Procedure Call-->
<h3 id="call">Procedure Call</h3>
<!--     #endregion-->
<!--     #region Each loop-->
<h3 id="each">Each loop</h3>
<!--     #endregion-->
<!--     #region Else clause-->
<h3 id="else">Else clause</h3>
<!--     #endregion-->
<!--     #region For loop-->
<h3 id="for">For loop</h3>
<p>The loop counter variable does not have to bave been defined in a <el-code>variable</el-code> statement.</p>
<p>The three defining values (<el-code>from</el-code>, <el-code>to</el-code>, and <el-code>step</el-code>) must all be integer, positive or negative.</p>
<p>They may be defined by literal integers, variables of Type <el-code>Int</el-code>, or expressions that evaluate to an integer. </p>
<p>However, if you require a negative step then the literal value, variable, or expression must start with a negative sign as this is needed at compile time to determine the nature of the exit condition. So if you have a variable <el-code>s</el-code> that holds a negative value to be used as the step, then you will need to write something like the following:</p>
<el-code-block>
variable s set to -3<br>
for i from 100 to 0 step -(-s)<br>
&nbsp;&nbsp;..<br>
end for
</el-code-block>
<!--     #endregion-->
<!--     #region If statement-->
<h3 id="if_statement">If statement</h3>
<p>See also <a href="if_expression">if expression</a></p>

<p>Example1:</p>

<el-code-block
  <el-statement class="multiline" id="if3" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr5" class="" tabindex="0"><el-txt><el-id>head</el-id><el-kw> is </el-kw><el-id>apple</el-id></el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw><el-fr>2</el-fr></el-top> <el-msg class=""></el-msg>
    <el-statement class=""" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>setAppleToRandomPosition</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional " tabindex="0"><el-txt><el-id>apple</el-id>, <el-id>body</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>) <el-msg class="">'setAppleToRandomPosition' is not defined</el-msg><el-fr>3</el-fr></el-top></el-statement>
    <el-statement class="ok outdent" id="else9" tabindex="0"><el-top>
<el-kw>else </el-kw><el-field id="elif11" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>if</i></el-place></el-field></el-top><el-msg></el-msg><el-fr>4</el-fr></el-statement>
    <el-statement class="" id="call12" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident13" class="" tabindex="0"><el-txt><el-id>body</el-id>.<el-method>removeAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args14" class="optional ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>arguments</i></el-place></el-field>) <el-msg class=""></el-msg><el-fr>5</el-fr></el-top></el-statement>
    <el-kw>end if</el-kw>
    </el-statement>
  </el-code-block>

<p>Example 2:</p>
<el-code><br>
if item is value then<br>
&nbsp;&nbsp;set result to true<br>
else if item.isBefore(value) then<br>
&nbsp;&nbsp;set result to binarySearch(list[..mid], item)<br>
else<br>
&nbsp;&nbsp;set result to binarySearch(list[mid + 1..], item)<br>
end if
</el-code><br>

<p>Notes</p>
<li>The <el-code>else</el-code> clause is optional</li>
<li>You can add as many <el-code>else if</el-code> clauses as you wish, but only one unconditional <el-code>else</el-code> (which, if present, must be the last clause).</li>
<!--     #endregion-->
<!--     #region Let statement-->
<h3 id="let">Let statement</h3>
<!--     #endregion-->
<!--     #region Print statement-->
<h3 id="print">Print statement</h3>

<p>The simplest way to print is with the <el-code>print</el-code> statement. For example</p>
<el-code><br>
print "Hello"<br>
let a be 3<br>
let b be 4<br>
print a * b<br>
print "{a} times {b} equals {a*b}"
</el-code><br>

<p>Note</p>
<li>The last line in the example above uses an &#8216;interpolated string&#8217; <!-- TODO - link -->. Arguments placed within curly braces are evaluated before printing, and these may be separated by literal text and punctuation as needed. This is one recommended way to print more than one value on a line. The other way is to use print procedures.</li>
<!--     #endregion-->
<!--     #region Repeat loop-->
<h3 id="repeat">Repeat loop</h3>
<!--     #endregion-->
<!--     #region Set statement-->
<h3 id="set">Set statement</h3>
<!--     #endregion-->
<!--     #region Throw statement-->
<h3 id="throw">Throw statement</h3>
<p>You can deliberately generate, or &#8216;throw&#8217;, an exception when a specific circumstance is identified with a <el-code>throw</el-code> statement, for example:</p>
<el-code>throw exception "something has happened"</el-code><br>
<!--     #endregion-->
<!--     #region Try statement-->
<h3 id="try">Try statement</h3>

<p>Where another piece of code might throw an exception, for example when calling a <a href="#System_methods">System method</a> that is dependent upon external conditions, it may be executed within a <el-code>try</el-code> statement, for example:</p>
<el-code>  try</el-code><br>
<el-code>    call foo()</el-code><br>
<el-code>    print "not caught"</el-code><br>
<el-code>  catch exception in e</el-code><br>
<el-code>    print e</el-code><br>
<el-code>  end try</el-code><br>

<p>The variable holding the exception (by default named <el-code>e</el-code>, but this may be changed by you) is of Type <el-code>String</el-code>. You may compare the exception message to one or more expected messages and, if the message does not match an expected exception, you may choose to throw the exception &#8216;up&#8217;, as in this example:</p>
<el-code>  try</el-code><br>
<el-code>    call foo()</el-code><br>
<el-code>    print "not caught"</el-code><br>
<el-code>  catch exception in e</el-code><br>
<el-code>    if e isnt "An expected message" then</el-code><br>
<el-code>      throw exception e</el-code><br>
<el-code>    end if</el-code><br>
<el-code>  end try</el-code><br>
<!--     #endregion-->
<!--     #region Variable statement-->
<h3 id="variable">Variable statement</h3>
<!--     #endregion-->
<!--     #region While loop-->
<h3 id="while">While loop</h3>
<!-- #endregion -->
<!--   #endregion -->
<!-- #endregion -->

<!-- #region Language Types-->
<!--   #region Heading & Intro-->
<h1 id="Type">Types defined as part of the language</h1>
<!--   #endregion-->
<!--   #region Int-->
<h2 id="Int">Int</h2>
<p>An integer or whole number, i.e. one that has no fractional component.</p>

<h3>Type name</h3>
<p><el-code>Int </el-code></p>

<h3>Defining a literal integer</h3>
<p><el-code>variable meaningOfLife set to 42</el-code></p>

<h3>Default value</h3>
<p>0</p>

<h3>Constraints</h3>
<li>Maximum value: 253 &#8211; 1 which is just over 9 &times; 1015</li>
<li>Minimum value: &#8211; (253 &#8211; 1)</li>
<p>If either limit is exceeded the number will automatically be represented as a <el-code>Float</el-code>, with possible loss of precision.</p>
<p>Notes</p>
<li>A value assigned to an <el-code>Int</el-code> may be expressed in decimal or, if preceded by <el-code>0x</el-code>, in hexadecimal. Hexadecimal is useful for defining <a href="#Colour">colours</a> and Unicode codepoint values.</li>
<li>An <el-code>Int</el-code> may always be passed as an argument into a method that specifies a <el-code>Float</el-code>.</li>
<!--   #endregion-->
<!--   #region Float-->
<h2 id="Float">Float</h2>
<p>A &#8216;floating-point number&#8217;, i.e. a number that may have both integer and fractional parts.</p>

<h3>Type name</h3>
<el-code>Float</el-code><br>

<h3>Defining literal floating-point value</h3>
<el-code>variable a set to 1.618</el-code><br>

<h3>Constraints</h3>
<p>Since Elan compiles to JavaScript, the constraints on floating point numbers are those of JavaScript:</p>
<li>Maximum value: just over 1 &times; 10308</li>
<li>Minimum value: approximately 5 &times; 10-324</li>
<p>For greater detail, refer to the official JavaScript documentation</p>
<p>Notes</p>
<p>
A variable that has been defined as being of Type <el-code>Float</el-code> may not be passed as an argument into a method that requires an <el-code>Int</el-code>, nor as an index into an <el-code>Array</el-code>, even if the variable contains no fractional part. However, it may be converted into an <el-code>Int</el-code> before passing, using the functions <el-code>floor()</el-code> or <el-code>ceiling()</el-code>:<br>
<el-code>floor()</el-code> returns the integer value left by removing any fractional part, and<br>
<el-code>ceiling()</el-code> returns the lowest integer greater than the <el-code>Float</el-code> value if does have a fractional part.</p>
<p>
If you wish to define a variable to be of Type <el-code>Float</el-code> but initialise it with an integer value then add <el-code>.0</el-code> on the end of the whole number, for example:<br>
<el-code>variable a set to 3.0</el-code>. </p>
<!--   #endregion-->
<!--   #region Boolean-->
<h2 id="Boolean">Boolean</h2>
<p>A <el-code>Boolean</el-code> value is either <el-code>true</el-code> or <el-code>false</el-code>.</p>

<h3>Type name</h3>
<el-code>Boolean</el-code><br>

<h3>Defining a literal Boolean</h3>
<p><el-code>variable a set to true</el-code> </p>
<p><el-code>true</el-code> and <el-code>false</el-code> must be written lower-case</p>

<h3>Default value</h3>
<el-code>false</el-code><br>
<!--   #endregion-->
<!--   #region String-->
<h2 id="String">String</h2>
<p>A <el-code>String</el-code> represents &#8216;text&#8217;  i.e. a sequence of zero or more characters.</p>

<h3>Type name</h3>
<el-code>String</el-code><br>

<h3>Defining a literal string value</h3>
<p><el-code>variable a set to "Hello"</el-code></p>
<p><el-code>String</el-code>s are always delineated by double-quotes.</p>

<h3>Default value</h3>
<p><el-code>""</el-code>, known as &#8216;the empty string&#8217;.</p>
<p>Notes</p>
<li>As in most programming languages, strings are immutable. When you apply any operation or function with the intent of modifying an existing string, the existing string is never modified. Instead, the operation or function will return a new string that is based on the original, but with the specified differences.</li>
<p>
<el-code>String</el-code>s may be appended to using the plus operator, for example<br>
<el-code>print</el-code> <el-code>"Hello" + " " + "World"</el-code></p>
<p>
A newline may be inserted within a string as <el-code>\n</el-code>, for example:<br>
<el-code>print "Hello\nWorld"</el-code></p>
<li>You may insert single-quotes  <el-code>' </el-code>within a string. </li>

<h3>Interpolated string</h3>
<p>
Elan strings are automatically interpolated. This means that you may insert the values of variables or simple expressions within a string by enclosing them in curly braces. For example (assuming that the variables <el-code>a</el-code> and <el-code>b</el-code> are already defined as integers) :<br>
<el-code>print "{a} times {b} equals {a*b}"</el-code></p>
<p>
You cannot include the characters <el-code>"</el-code>,<el-code> {</el-code>, or<el-code> }</el-code> directly within a literal string because of their special meanings. Instead, you use the constants <el-code>quotes</el-code>, <el-code>leftBrace</el-code> and <el-code>rightBrace</el-code> respectively:<br>
<el-code>print "This is double quote mark: " + quotes</el-code><br>
Alternatively, you can insert their Unicode codepoints by means of the <el-code>unicode()</el-code> standalone function:<br>
<el-code>print "This is a double quote mark: " + unicode(34)</el-code><br>
<p>or</p>
<el-code>print"Here are the curly braces: {unicode(123)} and {unicode(125)}"</el-code><br>

<h3 id="String_method">Dot methods on a String</h3>
<p>Note: There are no &#8216;substring&#8217; methods in Elan because you can always use an index range get a substring e.g. <el-code>s[3..7]</el-code>  gives a <el-code>string</el-code> containing the fourth through the eighth characters of <el-code>string s</el-code>. See<span class="Link"> Indexed Value</span>.</p>
<el-code>upperCase() returns String </el-code><br>
<p>returns a new string based on the input with all alpha-characters in upper-case.</p>
<el-code>lowerCase() returns String </el-code><br>
<p>returns a new string based on the input with all alpha-characters in lower-case.</p>
<el-code>contains(partString as String) returns Boolean</el-code><br>
<p>takes a single parameter of Type <el-code>String</el-code>, and returns a Boolean value indicating whether or not that argument <el-code>string</el-code> is contained within the <el-code>string</el-code> on which <el-code>contains</el-code> was called. Usage:</p>
<el-code><br>
variable a set to "Hello World!"<br>
print a.contains("ello")
</el-code><br>
<p>prints</span> true </p>
<el-code>replace(match as String, replacement as String) returns String</el-code><br>
<p>returns a new string where all occurrences of the <el-code>match</el-code> string are replaced with the <el-code>replacement</el-code> string. </p>
<el-code>trim() returns String</el-code><br>
<p>returns a new string based on the string on which the method is called, but with all leading and trailing spaces removed.</p>
<p id="indexOf"><el-code>indexOf(partString as String) returns Int</el-code></p>

<p>The following methods are used for comparing strings alphabetically,  for example in a sort routine:</p>
<el-code>isBefore(otherString as String) returns Boolean</el-code><br>
<el-code>isAfter(otherString as String) returns Boolean</el-code><br>
<el-code>isBeforeOrSameAs(otherString as String) returns Boolean</el-code><br>
<el-code>isAfterOrSameAs(otherString as String) returns Boolean</el-code><br>

<el-code>asUnicode() returns Int</el-code><br>
<p>returns the Unicode (integer) value for a character. If the string is more than one character long, the Unicode value returned is that for the first character in the string only. Note that the opposite method to create a single-character string from its numeric Unicode value is e.g. <el-code>unicode(123)</el-code> which returns <el-code>"{"</el-code>.</p>
<!--   #endregion-->
<!--   #region Arrays and Lists-->
<h2 id="Array_List">Arrays and Lists</h2>
<h3>Quick reference</h3>
<p>
<table>
<tr><th></th><th>Array</th><th>List</th></tr>
<tr><td>Type form</td><td><el-code>Array&lt;of String&gt;</el-code><br>2D: <el-code>Array2D&lt;of String&gt;</el-code></td><td><el-code>List&lt;of String&gt;</el-code></td></tr>
<tr><td>Literal</td><td><el-code>["plum", "pear"]</el-code></td><td><el-code>{"plum", "pear"}</el-code></td></tr>
<tr><td>Literal empty</td><td><el-code>empty Array&lt;of String&gt;</td><td><el-code>empty List&lt;of String&gt;</td></tr>
<tr><td>Initial size (filled with default values)</td><td><el-code>variable a set to createArray(10, "x")<br>
variable a set to createArray2D(8, 8, "")</el-code><br>
<p>In each case, the last argument is the value to which each element<br>is initialised, and defines the Type of elements in the Array</td><td>Not applicable</td></tr>
<tr><td>Read from position</td><td><el-code>a[3]<br>board[3][4]</el-code></td><td><el-code>a{3}</el-code></td></tr>
<tr><td>Read range</td><td><el-code>a[5..9]</el-code></td><td><el-code>a{5..9}</el-code></td></tr>
<tr><td>Put a value</td><td><el-code>call a.putAt(3, "pear")</el-code><br>2D: <el-code>call board.putAt2D(3,4,"K")</el-code><br></td><td><el-code>set a to a.withPutAt(3, "pear")</el-code></td></tr>
<tr><td>Append and prepend</td><td><el-code>call a.append("pear")<br>call a.prepend("pear")<br>call a.appendArray(anotherArray)<br>call a.prependArray(anotherArray)</el-code><br></td>
<td>Append one item: <el-code>set a to a + {"pear"}</el-code><br>Prepend one item: <el-code> set a to {"pear"} + a</el-code><br>Append or prepend a List: <el-code>set x to listA + listb</el-code><br></td></tr>
<tr><td>Insert</td><td><el-code>call a.insertAt(3, "pear")</el-code></td><td><el-code>set a to a.withInsertAt(3, "pear")</el-code></td></tr>
<tr><td>Remove by index</td><td><el-code>call a.removeAt(3)</el-code></td><td><el-code>set a to a.withRemoveAt(3)</el-code></td></tr>
<tr><td>Remove by value</td><td><el-code>call a.removeFirst("pear")<br>call a.removeAll("pear")</el-code></td><td><el-code>set a to a.withRemoveFirst ("pear")<br>set a to a.withRemoveAll ("pear")</el-code></td></tr>
<tr><td>Deconstruction into head (first element)<br>and tail (all the rest)</td><td>Not applicable</td><td><el-code>variable x:xs set to myList<br>
set h:t to myList</el-code><br>To discard either the head or the tail:<br><el-code>variable _:tail set to myList<br>variable head:_ set to myList</el-code></td></tr>
</table>
</p>

<h3 id="Array">Array</h3>
<p>An &#8216;Array&#8217; is a simple data structure that holds multiple elements of the same Type.</p>
<p>Unlike a List, an Array is mutable, meaning that the elements within the data structure can be altered without creating a new Array from the old.</p>
<p>The Type is specified in the following form:</p>
<el-code>Array&lt;of String&gt;</el-code> for an Array of Type >el-code>String</el-code><br>
<el-code>Array&lt;of Int&gt;</el-code> for an Array of Type <el-code>Int</el-code><br>

<p>where, in these examples, <el-code>String</el-code> and <el-code>Int</el-code> represent the Type of each element in the <el-code>Array</el-code>s. The element Type can be any Type value &#8211; <el-code>Int</el-code>, <el-code>Boolean</el-code>, <el-code>Float, String</el-code> &#8211; or the name of a specific <el-code>class</el-code> such as <el-code>Player</el-code>, or an <el-code>enum</el-code> such as <el-code>Direction</el-code>. It may also be another data structure, including another <el-code>Array</el-code> (sometimes referred to as a &#8216;nested Array&#8217;).</p>

<h4>Creating an Array</h4>
<p>An <el-code>Array</el-code> may be defined in &#8216;literal&#8217; form, &#8216;delimited&#8217; by square brackets, and with all the required elements separated by commas. The elements may be literal values but must all be of the same Type:</p>
<p><el-code>variable fruit set to ["apple", "orange", "pear"]</el-code></p>
<p>including &#8216;nested &#8217;:</p>
<p><el-code>variable coordinates set to [[3.4, 0.1, 7.8], [1, 0, 1.5], [10, -1.5, 25]]</el-code></p>
<p>or variables (provided they are all of the same Type):</p>
<p><el-code>variable values set to [x, y, z]</el-code></p>
<p>or a mixture of literal values and variables (all of the same Type):</p>
<p><el-code>variable values set to [3.1, y, z]</el-code></p>
<p>where <el-code>y </el-code>and <el-code>z </el-code>are existing variables of Type <el-code>Float</el-code>.</p>
<p>You may also define an <el-code>Array</el-code> of a specified size, with each element initialised to the same value, for example:</p>
<el-code>variable fruit set to createArray(20, "")</el-code></p>
<p>creates an <el-code>Array</el-code> of Type <el-code>String</el-code> with exactly 20 elements, each initialised to the empty String and:</p>
<el-code>variable scores set to createArray(12, 100.0)</el-code></p>
<p>creates an <el-code>Array</el-code> of Type <el-code>Float</el-code> with exactly 12 elements, each initialised to 100.0.</el-code</p>
<p>Although the resulting <el-code>Array</el-code> may still be expanded subsequently (by using the <el-code>add</el-code> procedure), the typical use for these two methods is for cases that would originally have used a traditional (fixed-size) array.</p>

<h3>Dot methods on an Array</h3>
<p>Functions:</p>
<p><el-code>myArray.contains(item) returns</el-code>s <el-code>true</el-code> or <el-code>false</el-code></p>
<p><el-code>myArray.asList() returns</el-code>s a <el-code>List</el-code> containing the same elements as the <el-code>Array</el-code> on which the method was called. This is often used to permit an <el-code>Array</el-code> to be passed into a function that has been designed to accept a <el-code>List</el-code>.</p>
<p>Procedures:</p>
<p>
<el-code>call fruit.append("banana")<br>
call fruit.appendArray(anotherArray)<br>
call fruit.insertAt(4, "cherry")<br>
call fruit.prepend("melon")<br>
call fruit.putAt(2, "grape")<br>
call fruit.removeAll("apple")<br>
call fruit.removeAt(3)<br>
call fruit.removeFirst("apple")
</el-code><br>

<h3 id="Using_an_Array">Using an Array</h3>
<p>Elements are read using an index in square brackets, the first element being element <el-code>[0]</el-code>. The last element of an <el-code>Array</el-code> of size 10 will therefore be accessed by the index <el-code>[9]</el-code>.</p>
<p>Attempting to read an element by index, where that element does not exist, will result in an &#8216;Index out of range&#8217; run-time error.</p>
<p>Unlike in many programming languages you may not modify data by index: elements are modified by calling the <el-code>putAt</el-code> procedure on the Array.</p>
<p>Try these examples (the last one will produce an error &#8211; make sure you understand why):</p>
<el-code>variable a set to createArray(10, 0)</el-code><br>
<el-code>print a</el-code><br>
<el-code>print a.length()</el-code><br>
<el-code>call a.putAt(0, 3)</el-code><br>
<el-code>call a.putAt(1, 7)</el-code><br>
<el-code>print a</el-code><br>
<el-code>print a[0]</el-code><br>
<el-code>print a[a.length() -1]</el-code><br>
<el-code>print a[a.length()]</el-code><br>
<p>
<p>Unlike in some languages, Elan Arrays may be dynamically extended, using <el-code>append</el-code> and <el-code>prepend</el-code> methods.</p>
<el-code>variable a set to createArray(3, 0)</el-code><br>
<el-code>variable b set to createArray(3, 10)</el-code><br>
<el-code>print a</el-code><br>
<el-code>print b</el-code><br>
<el-code>a.append(3)</el-code><br>
<el-code>b.prepend(7)</el-code><br>
<el-code>print a</el-code><br>
<el-code>print b</el-code><br>
<el-code>a.appendArray(b)</el-code><br>
<el-code>print a</el-code><br>
<el-code></el-code><br>

<h3 id="Array2D">2-dimensional Array</h3>
<p>In Elan, as in many languages, a &#8216;2-dimensional Array&#8217; is just an Array of Arrays. However, Elan provides a couple of convenient short-cut methods for working with such data structures:</p>
<el-code>variable board set to createArray2D(8, 8, "")</el-code><br>
will create an Array of Arrays with a total of 64 elements each of Type <el-code>String</el-code>, and initialised to the empty <el-code>String</el-code>. The Type is determined by the Type of the third parameter, which might be an <el-code>Int</el-code>, <el-code>Boolean</el-code>, or user-defined Type. It need not be an empty value. The <el-code>Array2D</el-code> need not be square &#8211; it may be rectangular.<br>
It is possible to create an 2-dimensional Array with no elements, for example by:</p>
<el-code>let a be new Array2D&lt;of Int&gt;()</el-code><br>

<p>However, this is not recommended as subsequently adding elements takes a lot of care and effort. It is recommended that you always use the method <el-code>createArray2D</el-code> to create a 2-dimensional Array initialised to the desired size. That way you can modify individual elements in the initialised Array with e.g.:</p>
<el-code>call board.putAt2D(3,4,"K")</el-code><br>

<p>and you can read individual elements with a double index, for example:</p>
<el-code>for col from 0 to 7 step 1</el-code><br>
<el-code>  for row from 0 to 7 step 1</el-code><br>
<el-code>    print board[col][row]</el-code><br>
<el-code>  end for</el-code><br>
<el-code>end for</el-code><br>

<p>If you want to define a function or procedure with a parameter that should be a 2-dimensional Array, the Type is specified as <el-code>Array2D</el-code>, for example:</p>

<el-code>Array2D&lt;of String&gt;</el-code><br>
<el-code>Array2D&lt;of Int&gt;</el-code><br>

<h3>Creating Arrays of specific sizes </h3>
<p>The following methods return an <el-code>Array</el-code> of a specified size, and with all elements initialised to a specified value. Although the resulting <el-code>Array</el-code> may still be expanded subsequently (by using the <el-code>add</el-code> procedure), the typical use for these two methods is for cases that would originally have used a traditional (fixed-size) array:</p>
<el-code>createArray(size as Int, initialValue as Type) returns [Type]</el-code><br>
<p>where <el-code>Type</el-code> is one of the following Types: <el-code>Int</el-code>, <el-code>Float</el-code>, <el-code>Boolean</el-code>, <el-code>String</el-code> or any Type of <el-code>enum</el-code>.</p>
<p>There is also a variant of the method that creates a &#8216;2-dimensional&#8217; rectangular <el-code>Array</el-code> (actually an <el-code>Array</el-code> of <el-code>Array</el-code>s):</p>
<el-code>createArray2D(noOfrows as Int, noOfColumns as Int, initialValue as T) returns [[Type]]</el-code><br>

<h3 id="List">List</h3>
<p>A <el-code>List</el-code> is a simple data structure that holds multiple elements of the same Type.</p>
<p> A <el-code>list</el-code>, like a <el-code>String</el-code> but unlike an <el-code>Array</el-code>, is immutable. You can still insert, delete, or change elements in a <el-code>List</el-code>, but the methods for these operations do not modify the input <el-code>List</el-code>: they return a new <el-code>List</el-code> based on the input <el-code>List</el-code> but with the specified differences. </p>

<h4>Type name</h4>
<p>The Type is specified in the following way:</p>
<el-code>List&lt;of String&gt;</el-code> for a List of Type<el-code>String</el-code><br>
<el-code>List&lt;of Int&gt;</el-code> for a </span>List  of Type <el-code>>Int</el-code><br>
List&lt;of List&lt;of Int&gt;&gt;</el-code> for a List of  Lists of Type </ode>Int</el-code><br>

<h4>Creating a List</h4>
<p>A <el-code>List</el-code> may be defined in &#8216;literal&#8217; form, &#8216;delimited&#8217; by curly braces, and with all the required elements separated by commas. The elements may be literal values but must all be of the same Type):</p>
<el-code>variable fruit set to {"apple", "orange", "pear"} </el-code><br>

<h3>Dot methods on a List</h3>
<p>The dot methods on a list are all functions.</p>
<el-code>myList.contains(item) returns true or false</el-code><br>
<el-code>myList.asArray() returns a new Array with the same contents as myList</el-code><br>

<p>The following functions all return a new <el-code>List</el-code>, copied from the <el-code>List</el-code> on which the function was called, but with the differences specified by the function parameters:</p>
<el-code>myList.withInsertAt(4, "cherry")</el-code><br>
<el-code>myList.withPutAt(2, "grape")</el-code><br>
<el-code>myList.withRemoveAt(3)</el-code><br>
<el-code>myList.withRemoveFirst("apple")</el-code><br>
<el-code>myList.withRemoveAll("apple")</el-code><br>

<p>Try these examples:</p>
<el-code>variable fruit set to empty List&lt;of String&gt;</el-code><br>
<el-code>print fruit</el-code><br>
<el-code>set fruit to fruit + "apple"</el-code><br>
<el-code>set fruit to fruit + "pear"</el-code><br>
<el-code>print fruit</el-code><br>
<el-code>set fruit to "orange" + "pear" </el-code><br>
<el-code>print fruit[0]</el-code><br>
<el-code>print fruit.length()</el-code><br>
<el-code>print fruit[fruit.length() -1]</el-code><br>
<el-code>variable head:tail set to fruit</el-code><br>
<el-code>print head</el-code><br>
<el-code>print tail</el-code><br>
<!--   #endregion-->
<!--   #region Dictionaries-->
<h2 id="Dictionary">Dictionaries</h2>
<p>There are two forms of dictionary in Elan: an ordinary <el-code>Dictionary</el-code> (which is mutable) and a <el-code>DictionaryImmutable</el-code> (which is not).</p>

<h3>Quick reference</h3>
<p>
<table>
<tr><th></th><th>Dictionary</th><th>DictionaryImmutable</th></tr>
<tr><td>Type form</td><td><el-code>Dictionary&lt;of String, Int&gt;</el-code></td><td><el-code>DictionaryImmutable&lt;of String, Int&gt;</el-code></td></tr>
<tr><td>Literal</td><td><el-code>["a":1, "b":4]</el-code></td><td><el-code>{"a":1, "b":4}</el-code></td></tr>
<tr><td>Literal empty</td>
<td><el-code>empty Dictionary&lt;of String, Int&gt;</el-code></td><td><el-code>empty DictionaryImmutable&lt;of String, Int&gt;</el-code></td></tr>
<tr><td>Read the value for a given key</td><td><el-code>d["a"]</el-code></td><td><el-code>d{"a"</el-code>}</td></tr>
<tr><td>Get all keys<br>Get all values</td><td colspan="2"><el-code>d.keys()</el-code >and <el-code>d.values()</el-code><br>both return an immutable list of the appropriate Type</td></tr>
<tr><td>Define (or change) a value associated with a key</td><td><el-code>call d.putAtKey("c", 7)</el-code></td><td><el-code>set d to d.withPutAtKey("c", 7)</el-code></td></tr>
<tr><td>Remove both key and value</td><td><el-code>call d.removeAtKey("c")</el-code></td><td><el-code>set d to d.withRemoveAtKey("c")</el-code></td></tr>
</table>
</p>

<h3 id="Dictionary">Dictionary</h3>

<h4>Type name</h4>
<p>In the following example, the keys are of Type <el-code>Int</el-code>, and the values associated with the keys are of Type <el-code>String</el-code>:</p>
<el-code>Dictionary&lt;of String, Int&gt;</el-code><br>

<p>For both <el-code>Dictionary</el-code> and <el-code>DictionaryImmutable</el-code> the values can be of any Type, including a specific Type of class, a <el-code>List</el-code>, another <el-code>Dictionary</el-code> or some other data structure. However, the key&#8217;s Type must be one of: <el-code>Int</el-code>, <el-code>Float</el-code>, <el-code>String</el-code>, <el-code>Boolean</el-code>, or a specific Type of <el-code>enum</el-code>.</p>

<h4>Defining a literal</h4>
<p>A literal <el-code>Dictionary</el-code> is defined as a comma-separated list of &#8216;key:value pairs&#8217; (key,colon.value) surrounded by square brackets:</p>
<el-code>variable scrabbleValues set to ["a":1, "b":3, "c":3, "d":2]</el-code><br>

<h4></h4>

<h4 id="Using_a_Dictionary">Using a Dictionary</h4>
<p>Try these examples:</p>
<el-code>variable dict set to new Dictionary&lt;of String, Int&gt;()</el-code><br>
<el-code>print dict</el-code><br>
<el-code>call dict.putAtKey("a", 3)</el-code><br>
<el-code>print dict["a"]</el-code><br>
<el-code>call dict.removeAtKey("a")</el-code><br>
<el-code>print dict</el-code><br>

<h4>Constraints</h4>

<p>Key values must be unique within a <el-code>Dictionary</el-code>.</p>
<p>There is no difference in syntax between adding an entry with a new key, and setting a new value for an existing key: if the key does not exist in the dictionary, it will be added.</p>

<h3>Dot methods on a Dictionary</h3>
<p>See also <span class="Link">Quick reference</span>.</p>
<el-code>putAtKey</el-code><br>
<el-code>removeAtKey</el-code><br>
<el-code>keys</el-code><br>
<el-code>values</el-code><br>
<el-code></el-code><br>

<h3 id="DictionaryImmutable">DictionaryImmutable</h3>
<p>An immutable dictionary may be defined in a <el-code>constant</el-code>.</p>

<h4>Type name</h4>
<p>In the following example, the keys are of Type <el-code>Int</el-code>, and the values associated with the keys are of Type <el-code>String</el-code>:</p>
<el-code>DictionaryImmutable&lt;of String, Int&gt;</el-code><br>

<h4>Defining a literal</h4>
<p>A literal<el-code> DictionaryImmutable</el-code> is defined as a comma-separated list of &#8216;key:value pairs&#8217; (key,colon.value) surrounded by curly braces:</p>
<el-code>variable scrabbleValues set to {"a":1, "b":3, "c":3, "d":2}</el-code><br>

<h4>Using an Immutable Dictionary</h4>
<p>Try these examples:</p>
<el-code>variable immD set to new DictionaryImmutable&lt;of String,Int&gt;()</el-code><br>
<el-code>print immD</el-code><br>
<el-code>set immD to immD.withPutAtKey("a", 3)</el-code><br>
<el-code>print immD["a"]</el-code><br>
<el-code>set immD to immD.withRemoveAtKey("a")</el-code><br>
<el-code>print immD</el-code><br>
<el-code></el-code><br>

<h3>Dot methods on an Immutable Dictionary</h3>
<p>See also <span class="Link">Quick reference</span>.</p>
<el-code>hasKey</el-code><br>
<el-code>withPutAtKey</el-code><br>
<el-code>withRemoveAtKey</el-code><br>
<el-code></el-code><br>
<!--   #endregion-->
<!--   #region Tuple-->
<h2 id="Tuple">Tuple</h2>
<p>A <el-code>tuple</el-code> is a way of holding a small number of values of different Types together as a single reference. They are referred to as 2-tuples, 3-tuples, etc. according to the number of values they hold. Common uses include:</p>
<p>Holding a pair of x and y coordinates (each of Type <el-code>Float</el-code>) as a single unit, and</p>
<p>Allowing a function to pass back a result comprised of both a message in a <el-code>String</el-code> and a <el-code>Boolean</el-code> indicating whether the operation was successful.</p>
<p>A <el-code>tuple</el-code> is considered a &#8216;lightweight&#8217; alternative to defining a specific class for some purposes. </p>

<h3>Type name</h3>
<p>Written as a comma-separated list of the Type of each member, surrounded by round brackets:</p>
<el-code>(Int, Int, Int)</el-code><br>
<el-code>(String, Boolean)</el-code><br>

<h3>Defining a literal tuple</h3>
<p>A <el-code>tuple</el-code> is defined, where it is needed, by the keyword <el-code>tuple</el-code> and a number of elements, each being a variable or a literal value, separated by commas and surrounded by round brackets, for example:</p>
<el-code><br>
let coords be tuple(x, y)<br>
let myList be {tuple(1,1), tuple(1, 2)}<br>
let foo be tuple(3.769, 4.088, true, 5, "correct")<br>
call proc1(a, coords, tuple(x, y))<br>
return tuple(3, 4)
</el-code><br>
</p>

<h3>Using a tuple</h3>
<p>You may pass a tuple into a function, or return one from a function, for example:</p>
<el-code>variable d set to distanceBetween(point1, tuple(12.34, 20.0))</el-code><br>
<br>
<p>An existing <el-code>tuple</el-code> (for example <el-code>point1 </el-code>below) may be &#8216;deconstructed&#8217; into new variables or named values (where the number of variables/names must match the number of elements in the <el-code>tuple</el-code>): </p>
<el-code>let x, y set to point1</el-code><br>
<el-code>variable x, y set to point1</el-code><br>
<p>
<br>
or into existing variables of the correct Type:</p>
<el-code>variable a set to 3</el-code><br>
<el-code>variable b set to 4</el-code><br>
<el-code>set a, b to point1</el-code><br>
<br>
<p>The &#8216;discard&#8217; symbol <el-code>_</el-code> (underscore) may also be used when deconstructing a tuple when there is no need to capture specific elements:</p>
<el-code>variable x, _ set to point1</el-code><br>
<br>
<p>Notes</p>
<p>As in most languages, Elan <el-code>tuple</el-code>s are immutable. Once defined they are effectively &#8216;read only&#8217;. You cannot alter any of the elements in a <el-code>tuple</el-code> nor (unpke a <el-code>pst</el-code> for example) can you create a new <el-code>tuple</el-code> from an existing one with specified differences.</p>
<p>You cannot deconstruct a <el-code>tuple</el-code> into a mixture of new and existing variables.</p>
<p><el-code>tuple</el-code>s may be nested: you can define a <el-code>tuple</el-code> within a <el-code>tuple</el-code>.</p>
<!--   #endregion-->
<!--   #region Func-->
<h3 id="Func">Func</h3>
<p>A <el-code>function</el-code> may be passed as an argument into another <el-code>function</el-code> (or a <el-code>procedure</el-code>), or returned as the result of calling another <el-code>function</el-code>. This pattern is known as &#8216;Higher order Function&#8217; (HoF), and is a key idea in the functional programming paradigm. To define a <el-code>function</el-code> that takes in another <el-code>function</el-code> as a parameter, or returns a <el-code>function</el-code>, you need to specify the Type of the <el-code>function</el-code>, just as you would specify the Type of every parameter and the return Type for the <el-code>function</el-code>. </p>

<h3>Type name</h3>
<p>The Type of any <el-code>function</el-code> starts with the word <el-code>Func</el-code> followed by angle brackets defining the Type of each parameter, and the return Type for that function, following this syntax:</p>
<el-code>Func&lt;of String, String, Int =&gt; Boolean&gt;</el-code><br>
<p>This example defines the Type for a function that defines three parameters of Type <el-code>String</el-code>, <el-code>String</el-code>, and <el-code>Int</el-code> respectively, and returns a <el-code>Boolean</el-code> value. T this Type would match that of a function definition that started:</p>
<el-code>Function charactersMatchAt(a as String, b as String, position as Int) returns Boolean</el-code><br>
<!--   #endregion-->
<!-- #endregion-->

<!-- #region Expressions-->
<!--   #region Heading & Intro-->
<h1 id="Expression">Expressions</h1>
<p>One of the most important constructs in programming is the &#8216;expression&#8217;. An expression is evaluated to return a value. An expression is made up of the following possible elements:</p>
<li>Literal value</li>
<li>Named value</li>
<li>Operator (including brackets)</li>
<li>Function call</li>
<p>which this chapter describes.</p>
<!--   #endregion-->
<!--   #region Literal value-->
<h2 id="Literal_value">Literal value</h2>
<p>A literal value is where a value is written &#8216;literally&#8217; in the code, such as <el-code>3.142</el-code> &#8211; in contrast to a value that is referred to by a name.</p>
<p>The following data Types may be written as literal values (follow the links to view the form of each literal value):</p>
<el-code><a href="#Int">Int</a>, <a href="#Float">Float</a>, <a href="#Boolean">Boolean</a>, <a href="#String">String</a>, <a href="#Array">Array</a>, <a href="#List">List</a>, <a href="#Dictionary">Dictionary</a>, <a href="#DictionaryImmutable">DictionaryImmutable</a>, <a href="#Tuple">Tuple</a></el-code><br>
<!--   #endregion-->
<!--   #region Named value-->
<h2 id="Named_value">Named value</h2>
<p>A named value is a value that is associated with a name rather than being defined literally in code. There are various kinds of named value:</p>
<p><a href="#Constant">Constant</a>, <span class="Hyperlink"><a href="#Let_statement_1">let</a></span> statement, <span class="Hyperlink"><a href="#Variables">variable</a></span> statement, <a href="#Parameter_passing_1">Parameter passing</a>, <span class="Hyperlink"><a href="#Enum_1">enum</a></span> statement</p>
<!--   #endregion-->
<!--   #region Identifier-->
<h3 id="Identifier">Identifier</h3>
<p>For all kinds of named values, the name must follow the rules for an &#8216;identifier&#8217;. It must start with a lower-case letter, followed by any combination of lower-case and upper-case letters, numeric digits, and the _ (underscore) symbol. It may not contain spaces or other symbols. Once a named value has been defined, it can be referred to by the name. </p>

<h3>Scoping and name qualification</h3>
<p>With the exception of a <el-code>constant</el-code> (below), which is global in scope, named values are always &#8216;local&#8217;: their scope is confined to the method in which they are defined. </p>
<p>Elan allows local named values to be defined with the same name as a constant, function, or procedure defined at global level or defined in the standard library. In such cases, when the name is used within the same method, then it will refer to the local definition. If you have done this, but then need to access the <el-code>constant</el-code>, <el-code>function</el-code>, or <el-code>procedure</el-code> with the same name, then you can simply prefix the use of the name with a &#8216;qualifier&#8217; of either <el-code>global.</el-code> or <el-code>library.</el-code> as appropriate.</p>
<!--   #endregion-->
<!--   #region Indexed Value-->
<h3>Indexed Value</h3>
<p>If a variable is of an indexable Type, then an index or index range may be applied to the variable within an expression. For example:</p>
<el-code>variable a set to "Hello World!"</el-code><br>
<el-code>print a[4]</el-code><br>
<el-code>print a[4..]</el-code><br>
<el-code>print a[..5]</el-code><br>
<el-code>print a[0..4]</el-code><br>

<p>See also: <a href="#Using_an_Array">Using an Array</a>, <a href="#Using_a_Dictionary">Using a Dictionary</a></p>
<p>Important: unlike in many languages, indexes in Elan (whether, single, multiple, or a range) are only ever used for reading values. Writing a value to a specific index location is done through a method such as:</p>
<p>
<el-code>putAt</el-code> on an	<el-code>Array</el-code><br>
<el-code>withPutAt</el-code>	on a	<el-code>List</el-code><br>
<el-code>putAtKey</el-code>	on a	<el-code>Dictionary</el-code><br>
<el-code>withPutAtKey</el-code>	on a	<el-code>DictionaryImmutable</el-code></p>
<!--   #endregion-->
<!--   #region Operator-->
<h2 id="Operator">Operators</h2>

<h3 id="Arithmetic_operator">Arithmetic operators</h3>
<p>Arithmetic operators can be applied to <el-code>Float</el-code> or <el-code>Int</el-code> arguments, but the result is always a <el-code>Float</el-code>:</p>
<p>
<el-code>2^3</el-code> &rarr; 8<br>
<el-code>2/3</el-code> &rarr; 0.666..<br>
<el-code>2*3</el-code> &rarr; 6<br>
<el-code>2 + 3</el-code> &rarr; 5<br>
<el-code>2 - 3</el-code> &rarr; -1<br>
<el-code>11 mod 3</el-code> &rarr; 2 (integer remainder)<br>
<el-code>11 div 3</el-code> &rarr; 3 (integer division)<br>
</p>
<p>Arithmetic operators follow the conventional rules for precedence i.e. &#8216;BIDMAS&#8217; (or &#8216;BODMAS&#8217;)</p>
<p>Note: When combining <el-code>div</el-code> or <el-code>mod</el-code> with any other operators within an expression, insert brackets to avoid ambiguity e.g.:</p>
<el-code>(5 + 6) mod 3</el-code><br>

<p>The minus sign may also be used as a unary operator, and this takes precedence over binary operators so:</p>
<p><el-code>2*-3</el-code> &rarr; -6</p>
<p>Note that the Elan editor automatically puts spaces around the <el-code>+</el-code> and <el-code>&#8211;</el-code> binary operators, but not around <el-code>^</el-code>, <el-code>/</el-code> or <el-code>*</el-code>. This is just to visually reinforce the precedence.</p>

<h3 id="Logical_operator">Logical operators</h3>
<p>Logical operators are applied to <el-code>Boolean</el-code> arguments and return a <el-code>Boolean</el-code> result.</p>
<p>
<el-code>and</el-code> and <el-code>or</el-code> are binary operators<br>
<el-code>not</el-code> is a unary operator. </p>
<p>The operator precedence is <el-code>not</el-code> &rarr; <el-code>and</el-code> &rarr; <el-code>or</el-code>. </p>
<p>Example that implements an &#8216;exclusive or&#8217;.</p>
<p>
<el-code><br>
function xor(a as Boolean, b as Boolean) returns Boolean<br>
&nbsp;&nbsp;return a and not b or b and not a<br>
end Function
</el-code><br>

<h3>Equality testing</h3>
<p>Equality testing uses the <el-code>is</el-code> and <el-code>isnt</el-code> keywords with two arguments. The arguments may be of any Type. </p>
<li><el-code>a is b</el-code> returns <el-code>true</el-code>, if <el-code>a</el-code> and <el-code>b</el-code> are both of the same Type and their values are equal. The only exception is that if one argument is of Type <el-code>Float</el-code> and the other is of Type <el-code>Int</el-code>, then <el-code>is</el-code> will return <el-code>true</el-code> if their values are the same, i.e. are the same whole number.</li>
<li><el-code>isnt</el-code> returns the opposite of <el-code>is</el-code></li>
<p>Note that in Elan equality testing is always &#8216;equality by value&#8217;; there is no such thing as &#8216;equality by reference&#8217;.</p>
<p>Note</p>
<li>Where a binary operator is expected, as soon as you type <el-code>is</el-code> the editor will automatically insert a space after it. To enter <el-code>isnt</el-code> you need to delete the space (using the Backspace key) and then type <el-code>nt</el-code>.</li>

<h3>Numeric comparison</h3>
<p>The numeric comparison operators are:</p>
<p>
<el-code>&gt;</el-code> 	for	greater than<br>
<el-code>&lt;</el-code>	for	less than<br>
<el-code>&gt;=</el-code> 	for	greater than or equal to<br>
<el-code>&lt;=</el-code> 	for	less than or equal to<br>
</p>
<p>Each is applied to two arguments of Type <el-code>Float</el-code>, but any variable or expression that evaluates to an <el-code>Int</el-code> may always be used where a <el-code>Float</el-code> is expected.</p>
<p>Notes</p>
<li>These operators cannot be applied to strings. Use the dot methods <el-code>isBefore</el-code> and <el-code>isAfter</el-code> to compare strings alphabetically. See <a href="#Dot_methods_on">Dot methods on a String</a>.</li>
<li>Where a binary operator is expected, as soon as you type <el-code>&lt; </el-code>or <el-code>&gt;</el-code> the editor will automatically insert a space after it. To enter <el-code>&lt;=</el-code> or <el-code>&gt;=</el-code> you need to delete the space (using the Backspace key) and then type <el-code>=</el-code>.</li>

<h3>Combining operators </h3>
<p>You can combine operators of different kinds, e.g. combining numeric comparison with logical operators in a single expression. However the rules of precedence between operators of different kinds are complex. It is strongly recommend that you always use brackets to disambiguate such expressions, for example:</p>
<el-code>(a &gt; b) and (b &lt; c)</el-code><br>
<el-code>(a + b) &gt; (c -d)</el-code><br>

<h2>Function call</h2>
<p>An expression may simply be a function call, or it may include one or more function calls within it. Examples:</p>
<el-code>print sinDeg(30)</el-code><br>
<el-code>variable x set to sinDeg(30)^2 + cosDeg(30)^2</el-code><br>
<el-code>variable name set to inputString("Your name")</el-code><br>
<el-code>print name.upperCase()</el-code><br>

<p>Notes</p>
<li>The third example above is not strictly a function call, but is a &#8216;system method&#8217;<span class="Link">Error! Reference source not found.</span> call. System methods may only be used within the <span class="Link">Main routine</span> or a Functions and procedure, because they have external dependencies or side effects.</li>
<li>In the fourth example, <el-code>upperCase</el-code> is a &#8216;dot method&#8217; that may be applied to any instance (variable or literal) of Type <el-code>String</el-code>. See <span class="Link">Dot methods on a String</span>.</li>
<!--   #endregion-->
<!--   #region Lambda-->
<h2 id="lambda">Lambda</h2>
<p>A lambda is lightweight means to define a function &#8216;in line&#8217;. You typically define a <el-code>lambda</el-code>:</p>
<li>If the functionality it defines is needed in only one location; typically for a particular call to a HoF.</li>
<li>If you need to capture a local variable in the implementation. This is called &#8216;closing around a variable&#8217;.</li>
<p>The syntax for a <el-code>lambda</el-code> is as follows:</p>
<li>Start with the keyword <el-code>lambda</el-code>.</li>
<li>Parameter definitions, comma-separated, follow the same form as parameter definitions in a function or procedure, but with out surrounding brackets.</li>
<li>The<el-code> =&gt;</el-code> symbol, which is usually articulated as &#8216;returns&#8217;,  &#8216;yields&#8217; or even &#8216;fat arrow&#8217;.</li>
<li>An expression that makes use of the parameters, and may also make use of other variables that are in scope. </li>

<p>Example:</p>
<el-code><br>
function liveNeighbours(cells as [Boolean], c as Int) returns Int<br>
&nbsp;&nbsp;let neighbours be neighbourCells(c)<br>
&nbsp;&nbsp;let live be neighbours.filter(lambda i as Int =&gt; cells[i])<br>
&nbsp;&nbsp;return live.length()<br>
end function<br>
</el-code><br>
<p>Notes</p>
<li>Although a lambda is commonly defined &#8216;inline&#8217; (as shown above) it is possible to assign a lambda to a variable and hence to re-use it within the scope of that variable. </li>
<li>Although a lambda will usually define at least one parameter, it is possible to define a lambda with no parameter, just returning an expression, in which case it acts just like a locally defined variable, but with the advantage (useful in rare circumstances) that the expression is evaluated &#8216;lazily&#8217; i.e. only when the lambda is used.</li>
<p>The following example uses both these techniques within a function:</p>
<el-code><br>
function safeSquareRoot(x as Float) returns Float<br>
&nbsp;&nbsp;let root be lambda =&gt; sqrt(x)<br>
&nbsp;&nbsp;return if x &lt; 0 then 0 else root()<br>
end function
</el-code><br>
<!--   #endregion-->
<!--   #region If expression-->
<h2 id="if_expression">If expression</h2>
<p>The &#8216;if expression&#8217; is in certain respects similar to an <span class="Link">If statement</span>, but with the following differences:</p>
<li>It is written entirely within a single expression. This is possible because the <el-code>if</el-code> expression always returns a value.</li>
<li>There is always a single <el-code>then</el-code> and a single <el-code>else</el-code> clause, and each clause contains just a single expression. The <el-code>if</el-code> expression returns the result of evaluating one of these two expressions, according to whether the condition evaluates to <el-code>true</el-code> or <el-code>false</el-code>.</li>
<p>Here are three examples:</p>
<el-code>return if c &lt; 1160 then c + 40 </el-code><br>
<el-code> else c &#8211; 1160</el-code><br>

<el-code>return if isGreen(attempt, target, n) then setChar(attempt, n, "*") </el-code><br>
<el-code> else attempt</el-code><br>

<el-code>return if attempt[n] is "*" then attempt </el-code><br>
<el-code> else if isYellow(attempt, target, n) then setChar(attempt, n, "+") </el-code><br>
<el-code> else setChar(attempt, n, "_"))</el-code><br>
<!-- #endregion-->
<!-- #endregion-->
</body>
</html>