<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-GB">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="Documentation.css" rel="stylesheet">
<link href="colourScheme.css" rel="stylesheet">
<link href="elanStyle.css" rel="stylesheet">
<title>Elan Language Reference</title>
<script type="text/javascript" src="generated_toc.js"></script>
</head>
<body>
<div class="docTitle">Elan Language Reference</div>
<div class="docTOC">
<div id="generated-toc" class="generate_from_h1 generate_for_page"></div></div>

<!-- TODO: suggestion -->
<!-- for temporary note of where change is needed -->

<!-- #region Instruction Set-->
<!--   #region Heading & Intro-->
<h1 id="Instuction_set">Instruction Set</h1>
<p>This section defines the set of instructions that make up the Elan language and form the building blocks for any program.</p>
<p>There are three categories of instruction, which are distinguished where the instructions of that category are <em>located</em> within a program:</p>
<ul>
<li><a href="#Global">Global instructions</a> (also referred to simply as &lsquo;globals&rsquo;) are located <em>directly</em> within a code file.
  They are never indented from the left-hand edge, nor may they be located <em>within</em> other instructions.
  Three of the globals &ndash; <el-code>main</el-code>, <el-code>function</el-code>, and <el-code>procedure</el-code> &ndash; are described as &lsquo;methods&rsquo; and these defined one or more <a href="#Statement">statements</a> within them.</em>
  Four of the globals &ndash; <a href="#record"><el-code>record</el-code></a>, <a href="#class">class</a>, <a href="#Abstract_class"><el-code>abstract class</el-code></a>, and <a href="#interface"><el-code>interface</el-code></a> &ndash; define data structures and these always contain <a href="#Member">members</a>.
  The two remaining globals &ndash; <el-code>constant</el-code>, and <el-code>enum</el-code> &ndash; do not contain any further instructions.</li>
<li><a href="#Member">Member instructions</a> (also referred to simply as &lsquo;members&rsquo;) are located directly within the &lsquo;data structure&rsquo; globals: <el-code>record</el-code>, <el-code>class</el-code>, <el-code>abstract class</el-code>, <el-code>interface</el-code>.
  All members, with the exception of <el-code>property</el-code>, define one or more <a href="#Statement">statements</a> within them.</li>
<li><a href="#Statement">Statement instructions</a> (also referred to simply as &lsquo;statements&rsquo;) are located within &lsquo;methods&rsquo;. Some of these statements may contain other statements. </li>
</ul>
<p>All instructions are added into a program using the <el-code>new code</el-code> &lsquo;selectors&rsquo;.</p>

<h2 id="Comment">Comments</h2>
A comment is not an instruction: it is ignored by the compiler and does not change how the program works.
Rather, a comment contains information <em>about</em> the program, intended to be read by a person seeking to understand or modify the code.</p>
Every comment starts with the symbol <el-code>#</el-code> (known as &lsquo;hash&rsquo;) followed by some text or a blank line.
Comments may be inserted at the same level as a <a href="#Global">global</a>,
<a href="#Member">member</a>, or <a href="#Statement">statement</a> instruction, by entering <el-code>#</el-code> from the <el-code>new code</el-code> selector.</p>
<p> Every Elan program has a single comment at the top of the file, which is generated by the system and cannot be edited or deleted by the user.
  This comment is known as the &lsquo;header&rsquo; and gives the version of Elan being run together with other optional information that depend upon your user profile.</p>
<!-- #endregion-->
<!--   #region Global Instructions-->
<!--     #region Heading & Intro-->
<h2 id="Global">Global Instructions</h2>
<p>When you navigate to a <el-code>new code</el-code> that is at <em>global</em> level (not indented from the left-hand edge of the code pane)
you will be shown the set of globals that you may insert there, namely all or only some of:</p>
<a href="#main"><el-code>main</el-code></a>
<a href="#Procedure"><el-code>procedure</el-code></a>
<a href="#Function"><el-code>function</el-code></a>
<a href="#Test"><el-code>test</el-code></a>
<a href="#Constant"><el-code>constant</el-code></a>
<a href="#Enum"><el-code>enum</el-code></a>
<a href="#record"><el-code>record</el-code></a>
<a href="#class"><el-code>class</el-code></a>
<a href="#ClassAbs"><el-code>abstract</el-code></a>
<a href="#interface"><el-code>interface</el-code></a>
<a href="#comment"><el-code>#</el-code></a></p>
where <el-code>abstract</el-code> is, in this context, short for <a href="#Abstract_class"><el-code>abstract class</el-code></a>.

<el-code><el-global class="selected focused ok empty" id="select0" tabindex="0"><el-select><el-txt></el-txt><el-place>new code</el-place></el-select></el-global></el-code>

<p>The specific globals offered will depend upon your user profile.</p>

<!-- #endregion-->
<!--     #region Main method-->
<h3 id="main">Main method</h3>
<p>A file must have a <el-code>main</el-code> method if it is intended to be run as a program. You may, however, develop and test code that does not have a <el-code>main</el-code> method, either as a coding exercise or for subsequent use within another program.</p>
<p>The <el-code>main</el-code> method defines the start point when a program is run.</p>
<p>The <el-code>main</el-code> method does not have to be at the top of the file, but this is a good convention to follow.</p>
<p>The <el-code>main</el-code> method may delegate work to one or more <a href="#procedure">procedure</a> or <a href="#function">function</a>.</p>
<p>There may not be more than one <el-code>main</el-code> method in a file &ndash; and the global selector (above) will not show the <el-code>main</el-code> option when one already exists in the file.</p>
Example:

<el-code-block source="main.elan">
<main class="multiline" id="main1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>main</el-kw> <el-msg class="warning"></el-msg></el-top>
<el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>[<el-lit>3</el-lit>, <el-lit>6</el-lit>, <el-lit>1</el-lit>, <el-lit>0</el-lit>, <el-lit>99</el-lit>, <el-lit>4</el-lit>, <el-lit>67</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="warning" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>inPlaceRippleSort</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end main</el-kw></main>
</el-code-block>

<!-- #endregion-->
<!--     #region Procedure-->
<h3 id="procedure">Procedure</h3>
<p id="Argument">A procedure is a named piece of behaviour that can define <b>parameters</b> which are given inputs via <b>arguments</b> in a <el-code>call</el-code> statement.
Unlike a <a href="#function">function</a>, a procedure does not return a value.
  Also unlike a function, a procedure can have &lsquo;side effects&rsquo;: indeed it <em>should</em> have side effects, otherwise there would be no point in calling it!
  For this reason the statements within a procedure can:</p>
<ul>
<li>Include <el-code>print</el-code> statements (or methods).</li>
<li>include <el-code>input</el-code> methods or other &lsquo;system&rsquo; methods (such as a random number generation).</li>
<li><el-code>call</el-code> other procedures (or itself if <a href="#Recursion">&lsquo;recursion&rsquo;</a> is required).</li>
<li>Re-assign a parameter, provided that parameter definition is preceded by the keyword <el-code>out</el-code>, as in this example:</li>
</ul>
<el-code-block source="inPlaceRippleSort.elan">
  <el-proc class="ok multiline" id="proc11" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident13" class="ok" tabindex="0"><el-txt>inPlaceRippleSort</el-txt><el-place><i>name</i></el-place>></el-field></el-method>(<el-field id="params14" class="optional ok" tabindex="0"><el-txt><el-kw>out</el-kw> <el-id>arr</el-id> <el-kw>as</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;</el-txt><el-place><i>parameter definitions</i></el-place></el-field>)</el-top>
  <el-statement class="ok" id="var15" tabindex="0"><el-kw>variable </el-kw><el-field id="var16" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="var18" tabindex="0"><el-kw>variable </el-kw><el-field id="var19" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr20" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>length</el-method>() - <el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok multiline" id="repeat21" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>repeat</el-kw></el-top>
  <el-statement class="ok" id="set24" tabindex="0"><el-kw>set </el-kw><el-field id="ident25" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr26" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok multiline" id="for27" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident29" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr30" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr31" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr32" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
  <el-statement class="ok multiline" id="if33" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr35" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>[<el-id>i</el-id>] &gt; <el-id>arr</el-id>[<el-id>i</el-id> + <el-lit>1</el-lit>]</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
  <el-statement class="ok" id="let36" tabindex="0"><el-kw>let </el-kw><el-field id="var37" class="ok" tabindex="0"><el-txt><el-id>temp</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr38" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>[<el-id>i</el-id>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="call39" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident40" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>putAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args41" class="optional ok" tabindex="0"><el-txt><el-id>i</el-id>, <el-id>arr</el-id>[<el-id>i</el-id> + <el-lit>1</el-lit>]</el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="call42" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident43" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>putAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args44" class="optional ok" tabindex="0"><el-txt><el-id>i</el-id> + <el-lit>1</el-lit>, <el-id>temp</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="set45" tabindex="0"><el-kw>set </el-kw><el-field id="ident46" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr47" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end if</el-kw>
  </el-statement>
  <el-kw>end for</el-kw>
  </el-statement>
  <el-statement class="ok" id="set48" tabindex="0"><el-kw>set </el-kw><el-field id="ident49" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr50" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id> - <el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end repeat when </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt><el-kw>not</el-kw> <el-id>changes</el-id></el-txt><el-place><i>condition</i></el-place></el-field>
  </el-statement>
  <el-kw>end procedure</el-kw>
  </el-proc>
</el-code-block>
<p>Procedures are executed by means of a <a href="#call">call</a> statement, for example:</p>
<el-code-block source="sort.elan">
<main class="ok multiline" id="main1" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>main</el-kw></el-top>
  <el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>[<el-lit>3</el-lit>, <el-lit>6</el-lit>, <el-lit>1</el-lit>, <el-lit>0</el-lit>, <el-lit>99</el-lit>, <el-lit>4</el-lit>, <el-lit>67</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>inPlaceRippleSort</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end main</el-kw>
</main>
</el-code-block>
<!-- #endregion-->
<!--     #region Function-->
<h3 id="function">Function</h3>
<p>A <el-code>function</el-code> is a named piece of behaviour that can define <b>parameters</b> which are given inputs via <b>arguments</b> when reference to the function occurs in an expression.
Unlike a <a href="#procedure">procedure</a>, a function returns a value. Also unlike a procedure, a function can have no &lsquo;side effects&rsquo; and may not depend on any <a href="#System_methods">System methods</a>.</p>
Example of a function:</p>
<el-code-block source="score.elan">
<el-func class="ok multiline" id="func91" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident93" class="ok" tabindex="0"><el-txt>score</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params94" class="optional ok" tabindex="0"><el-txt><el-id>g</el-id> <el-kw>as</el-kw> <el-type>Game</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type95" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return96" tabindex="0"><el-kw>return </el-kw><el-field id="expr97" class="ok" tabindex="0"><el-txt><el-id>g</el-id>.<el-id>body</el-id>.<el-method>length</el-method>() - <el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<!-- #endregion-->
<!--     #region Parameters-->
<div id="as"></div>
<h3 id="Parameter">Parameters</h3>
Parameters for both <el-code>procedures</el-code> and <el-code>functions</el-code> are defined in exactly the same way: each parameter definition takes the form:
<br>&nbsp;&nbsp;&lt;name&gt; <el-code>as</el-code> &lt;Type&gt;
<br> for example:
<el-code-block source="ageAsInt.elan">
<el-field id="params50" class="optional ok" tabindex="0"><el-txt><el-id>age</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>
</el-code-block>

<!-- #endregion-->
<!--     #region Recursion-->
<h3 id="Recursion">Recursion</h3>
Procedures and functions may be called or referenced recursively. For example, a simple factorial calculation:
<el-code-block source="factorial.elan">
<el-func class="ok multiline" id="func1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident3" class="ok" tabindex="0"><el-txt>factorial</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params4" class="optional ok" tabindex="0"><el-txt><el-id>n</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type5" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return6" tabindex="0"><el-kw>return </el-kw><el-field id="expr7" class="ok" tabindex="0"><el-txt>(<el-kw>if </el-kw><el-id>n</el-id> &gt; <el-lit>1</el-lit><el-kw> then </el-kw><el-id>n</el-id>*<el-method>factorial</el-method>(<el-id>n</el-id> - <el-lit>1</el-lit>)<el-kw><br>else </el-kw><el-lit>1</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>
<!-- #endregion-->
<!--     #region Test-->
<h3 id="test">Test</h3>
<p>A <el-code>test</el-code> is a set of assertions, at the global level, about the output of functions. Example of a <el-code>test</el-code>, from the binary search demo program:</p>

<el-code-block source="test_search.elan">
<el-test class="ok multiline" id="test74" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment76" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let77" tabindex="0"><el-kw>let </el-kw><el-field id="var78" class="ok" tabindex="0"><el-txt><el-id>li1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr79" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>", "<el-lit>lime</el-lit>", "<el-lit>orange</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert80" tabindex="0"><el-kw>assert </el-kw><el-field id="text81" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr82" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert83" tabindex="0"><el-kw>assert </el-kw><el-field id="text84" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>lime</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr85" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert86" tabindex="0"><el-kw>assert </el-kw><el-field id="text87" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>orange</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr88" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert89" tabindex="0"><el-kw>assert </el-kw><el-field id="text90" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr91" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let92" tabindex="0"><el-kw>let </el-kw><el-field id="var93" class="ok" tabindex="0"><el-txt><el-id>li2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr94" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>", "<el-lit>orange</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert95" tabindex="0"><el-kw>assert </el-kw><el-field id="text96" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr97" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert98" tabindex="0"><el-kw>assert </el-kw><el-field id="text99" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>orange</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr100" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert101" tabindex="0"><el-kw>assert </el-kw><el-field id="text102" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr103" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let104" tabindex="0"><el-kw>let </el-kw><el-field id="var105" class="ok" tabindex="0"><el-txt><el-id>li3</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr106" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert107" tabindex="0"><el-kw>assert </el-kw><el-field id="text108" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li3</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr109" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert110" tabindex="0"><el-kw>assert </el-kw><el-field id="text111" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li3</el-id>, "<el-lit>lime</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr112" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let113" tabindex="0"><el-kw>let </el-kw><el-field id="var114" class="ok" tabindex="0"><el-txt><el-id>li4</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr115" class="ok" tabindex="0"><el-txt><el-kw>empty</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>&gt;</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert116" tabindex="0"><el-kw>assert </el-kw><el-field id="text117" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li4</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr118" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

Notes:
<ul>
<li>Elan tests are designed to test <el-code>function</el-code>s only. It is not possible to call a <el-code>procedure</el-code> or <el-code>main</el-code> routine within a test. Nor is it possible to use any <a href="#System_methods">System method</a> (the same rule as for a function).</li>
<li>A test may optionally be given a name or description in free-form text, just like a comment, which plays no role in the execution of the test. You might give the test the same name as a function that it is testing, or you might describe a particular scenario that is being tested.</li>
<li><el-code>test</el-code> methods may be written anywhere in the code, at the global level. </li>
<li>A test method may contain any number of <el-code>assert</el-code> statements. When tests are run, the test runner (part of the Elan IDE), will attempt to run all <el-code>assert</el-code> statements and show each one's pass or fail outcome alongside. However, if the test hits a runtime error (as distinct from an <el-code>assert</el-code> failure) then execution of the test will stop and remaining <el-code>assert</el-code>s will be shown as &lsquo;not run&rsquo;.</li>
<li>In addition to <el-code>assert</el-code> statements, a <el-code>test</el-code> may contain any other statements that may be added into a <el-code>function</el-code> (except <el-code>return</el-code>).</li>
<li>All <el-code>assert</el-code>s should be at the top level within the <el-code>test</el-code> frame; none may be put into a loop structure.<a name="GoBack"></a></li>
</ul>

<h4 class="no-TOC">Testing Float values</h4>
<p>When testing <el-code>Float</el-code> values it is recommend that you always use the <el-code>round</el-code> function to round the computed result to a fixed number of decimal places. This avoids rounding errors and is easier to read:</p>

<el-code-block source="test_round.elan">
<el-test class="ok multiline" id="test3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment5" class="optional ok" tabindex="0"><el-txt>round()</el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="assert14" tabindex="0"><el-kw>assert </el-kw><el-field id="text15" class="ok" tabindex="0"><el-txt><el-method>sqrt</el-method>(<el-lit>2</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr16" class="ok" tabindex="0"><el-txt><el-lit><el-lit>1</el-lit>.414</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<h4 class="no-TOC">Testing for runtime errors</h3>
<p>If the expression you are testing causes a runtime error then the error will be displayed in the red fail message:</p>
<el-code-block source="test_runtime.elan">
<el-test class="error multiline" id="test5" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment7" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let62" tabindex="0"><el-kw>let </el-kw><el-field id="var63" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr64" class="ok" tabindex="0"><el-txt>[<el-lit>5</el-lit>, <el-lit>1</el-lit>, <el-lit>7</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert77" tabindex="0"><el-kw>assert </el-kw><el-field id="text78" class="ok" tabindex="0"><el-txt><el-id>a</el-id>[<el-lit>0</el-lit>]</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr79" class="ok" tabindex="0"><el-txt><el-lit>5</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert84" tabindex="0"><el-kw>assert </el-kw><el-field id="text85" class="ok" tabindex="0"><el-txt><el-id>a</el-id>[<el-lit>2</el-lit>]</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr86" class="ok" tabindex="0"><el-txt><el-lit>7</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert91" tabindex="0"><el-kw>assert </el-kw><el-field id="text92" class="ok" tabindex="0"><el-txt><el-id>a</el-id>[<el-lit>3</el-lit>]</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr93" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="error">actual: Out of range index: 3 size: 3</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<p>If this occurs, mark the tests that you added since the last successful test run with <el-code>ignore</el-code> (see below), and then remove the <el-code>ignore</el-code>s one by one until the cause is identified and can be fixed.</p>

<h4 class="no-TOC">Marking a test with &lsquo;ignore&rsquo;</h4>
<p>It is possible to mark a <el-code>test</el-code> with the <el-code>ignore</el-code> keyword, by selecting the <el-code>test</el-code> frame and then hitting Ctrl-i, as in this example:</p>

<el-code-block source="test_ignore.elan">
<el-test class="warning multiline" id="test213" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>ignore test </el-kw><el-field id="comment215" class="optional ok" tabindex="0"><el-txt>clockTick</el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let216" tabindex="0"><el-kw>let </el-kw><el-field id="var217" class="ok" tabindex="0"><el-txt><el-id>g1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr218" class="ok" tabindex="0"><el-txt><el-method>newGame</el-method>(<el-kw>new</el-kw> <el-type>Random</el-type>())</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let219" tabindex="0"><el-kw>let </el-kw><el-field id="var220" class="ok" tabindex="0"><el-txt><el-id>g2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr221" class="ok" tabindex="0"><el-txt><el-method>newApple</el-method>(<el-id>g1</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let222" tabindex="0"><el-kw>let </el-kw><el-field id="var223" class="ok" tabindex="0"><el-txt><el-id>g3</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr224" class="ok" tabindex="0"><el-txt><el-method>clockTick</el-method>(<el-id>g2</el-id>, "<el-lit>s</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert225" tabindex="0"><el-kw>assert </el-kw><el-field id="text226" class="ok" tabindex="0"><el-txt><el-id>g3</el-id>.<el-id>head</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr227" class="ok" tabindex="0"><el-txt><el-method>newSquare</el-method>(<el-lit>22</el-lit>, <el-lit>16</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="warning">not run</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block></p>
<p>When a test is marked with <el-code>ignore</el-code>, that test will not be executed when the tests are run, and its result will be shown as &lsquo;not run&rsquo;. The overall test status will also show in the &lsquo;warning&rsquo; status (amber colour), even if all the tests that did run passed. This is to discourage you from leaving a test marked <el-code>ignore</el-code> for long.</p>
<p>The principal reason for marking a test <el-code>ignore</el-code> is when either the test code, or code in any function being called, does not terminate. This typically means that there is a loop (or a recursive call) with no exit condition, or where the exit condition is never met.</p>
<p>If you do create such code without realising it, then when the tests are executed the test runner will &lsquo;time out&rsquo; after a few seconds (most tests will pass in milliseconds), and an error message will be shown in the System info pane. The test that caused the timeout will automatically then be marked <el-code>ignore</el-code>. Your priority should then be to identify the cause of the timeout and attempt to fix it before then restoring the <el-code>test</el-code> by selecting its frame and hitting <el-code>Ctrl-i</el-code> {which is a toggle for setting and unsetting an <el-code>ignore</el-code> status).</p>
<!-- #endregion-->
<!--     #region Constant-->
<h3 id="constant">Constant</h3>
<p>A <el-code>constant</el-code> defines a named value that cannot change and is always defined at global level (directly within a file) and is global in scope.</p>
<ul>
<li>A <el-code>constant</el-code> may not be defined within any method. (However, see<a href=""</a>)<!-- TODO missing link -->.</li>
<li>The name of a <el-code>constant</el-code> follows the rules for an <a href="#Identifier">Identifier</a>.</li>
<li>The value to which a constant is set must be a <span class="Link">Literal value</span> of one of the following Types: <el-code>Int</el-code>, <el-code>Float</el-code>, <el-code>Boolean</el-code>, <el-code>String</el-code>, <el-code>Dictionary</el-code> or <el-code>DictionaryImmutable</el-code>.</li>
</ul>
Examples:

<el-code-block source="constants_enum.elan">
<el-const class="ok multiline" id="const5" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident6" class="ok" tabindex="0"><el-txt><el-id>phi</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text7" class="ok" tabindex="0"><el-txt><el-lit><el-lit>1</el-lit>.618</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const16" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident17" class="ok" tabindex="0"><el-txt><el-id>maxHits</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text18" class="ok" tabindex="0"><el-txt><el-lit>10</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const23" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident24" class="ok" tabindex="0"><el-txt><el-id>warningMsg</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text25" class="ok" tabindex="0"><el-txt>"<el-lit>Limit reached</el-lit>"</el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const30" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident31" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text32" class="ok" tabindex="0"><el-txt>{"<el-lit>apple</el-lit>", "<el-lit>orange</el-lit>", "<el-lit>banana</el-lit>"}</el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const39" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident40" class="ok" tabindex="0"><el-txt><el-id>black</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text41" class="ok" tabindex="0"><el-txt><el-lit>0x000000</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const46" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident47" class="ok" tabindex="0"><el-txt><el-id>red</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text48" class="ok" tabindex="0"><el-txt><el-lit>0xff0000</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const75" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident76" class="ok" tabindex="0"><el-txt><el-id>colours</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text77" class="ok" tabindex="0"><el-txt>{<el-type>Suit</el-type>.<el-id>spades</el-id>:<el-id>black</el-id>, <el-type>Suit</el-type>.<el-id>hearts</el-id>:<el-id>red</el-id>, <el-type>Suit</el-type>.<el-id>diamonds</el-id>:<el-id>red</el-id>, <el-type>Suit</el-type>.<el-id>clubs</el-id>:<el-id>black</el-id>}</el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const65" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident66" class="ok" tabindex="0"><el-txt><el-id>scrabbleValues</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text67" class="ok" tabindex="0"><el-txt>{"<el-lit>A</el-lit>":<el-lit>1</el-lit>, "<el-lit>B</el-lit>":<el-lit>3</el-lit>, "<el-lit>C</el-lit>":<el-lit>3</el-lit>, "<el-lit>D</el-lit>":<el-lit>2</el-lit>, "<el-lit>E</el-lit>":<el-lit>1</el-lit>, "<el-lit>F</el-lit>":<el-lit>4</el-lit>, "<el-lit>G</el-lit>":<el-lit>2</el-lit>, "<el-lit>H</el-lit>":<el-lit>4</el-lit>, "<el-lit>I</el-lit>":<el-lit>1</el-lit>, "<el-lit>J</el-lit>":<el-lit>8</el-lit>, "<el-lit>K</el-lit>":<el-lit>5</el-lit>, "<el-lit>L</el-lit>":<el-lit>1</el-lit>, "<el-lit>M</el-lit>":<el-lit>3</el-lit>, "<el-lit>N</el-lit>":<el-lit>1</el-lit>, "<el-lit>O</el-lit>":<el-lit>1</el-lit>, "<el-lit>P</el-lit>":<el-lit>3</el-lit>, "<el-lit>Q</el-lit>":<el-lit>10</el-lit>, "<el-lit>R</el-lit>":<el-lit>1</el-lit>, "<el-lit>S</el-lit>":<el-lit>1</el-lit>, "<el-lit>T</el-lit>":<el-lit>1</el-lit>, "<el-lit>U</el-lit>":<el-lit>1</el-lit>, "<el-lit>V</el-lit>":<el-lit>4</el-lit>, "<el-lit>W</el-lit>":<el-lit>4</el-lit>, "<el-lit>X</el-lit>":<el-lit>8</el-lit>, "<el-lit>Y</el-lit>":<el-lit>4</el-lit>, "<el-lit>Z</el-lit>":<el-lit>10</el-lit>}</el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
</el-code-block>
<p>In the <el-id>colours</el-id> example above, <el-code>Suit</el-code> is an <a href="#Enum_1">Enum</a>.</p>

<h3 id="enum">Enum</h3>
<p>An <el-code>enum</el-code> &ndash; short for &lsquo;enumeration&rsquo; &ndash; is the simplest form of &lsquo;user-defined Type&rsquo;.
It specifies a set of values, each of which is defined as a name, such that a named value of Type <el-code>enum</el-code> necessarily always holds one of those values.</p>
<el-code>enum</el-code>s are read-only: once they have been defined it is not possible to add, remove, or update their values.</p>

Examples:

<el-code-block source="constants_enum.elan">
<el-enum class="ok multiline" id="enum120" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type121" class="ok" tabindex="0"><el-txt><el-type>Suit</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals122" class="ok" tabindex="0"><el-txt><el-id>spades</el-id>, <el-id>hearts</el-id>, <el-id>diamonds</el-id>, <el-id>clubs</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
<el-enum class="ok multiline" id="enum137" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type138" class="ok" tabindex="0"><el-txt><el-type>Action</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals139" class="ok" tabindex="0"><el-txt><el-id>stand</el-id>, <el-id>draw</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
<el-enum class="ok multiline" id="enum140" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type141" class="ok" tabindex="0"><el-txt><el-type>Outcome</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals142" class="ok" tabindex="0"><el-txt><el-id>undecided</el-id>, <el-id>win</el-id>, <el-id>lose</el-id>, <el-id>draw</el-id>, <el-id>winDouble</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
<el-enum class="ok multiline" id="enum143" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type144" class="ok" tabindex="0"><el-txt><el-type>Status</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals145" class="ok" tabindex="0"><el-txt><el-id>pending</el-id>, <el-id>playing</el-id>, <el-id>standing</el-id>, <el-id>blackjack</el-id>, <el-id>bust</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
</el-code-block>

<h3>Type name</h3>
<p>The name given to an <el-code>enum</el-code> (see below), which must begin with an upper case letter, is used as the Type name when passing a value to or from a procedure or function. </p>

<h4 class="no-TOC">Using an enum</h4>
The value is specified by the Type name for the specified <el-code>enum</el-code>, followed by a dot and the value name, for example:

<el-code-block source="enum_status.elan">
<el-statement class="ok" id="var69" tabindex="0"><el-kw>variable </el-kw><el-field id="var70" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr71" class="ok" tabindex="0"><el-txt><el-type>Status</el-type>.<el-id>pending</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<!-- #endregion-->
<!--     #region Record-->
<h3 id="record">Record</h3>

<p>A <el-code><el-kw>record</el-kw></el-code> is a user-defined data structure that is given a Type name (which must begin with an upper case letter).
  The <el-code>record</el-code> defines one or more properties, each of which has a name (starting with a lower case letter) and a Type.
  The Type of a property may be any simple value Type, or a ListImmutable, or another Type of <el-code>record</el-code> ( or even the same Type of <el-code>record</el-code>).</p>
  <p>Note that the Type <el-code><el-kw>record</el-kw></el-code> has some similarity to a <a href="#class">class</a> in that:</p>
<ul>
  <li>Both are user-defined data structures</li>
  <li>Both are given a &lsquo;Type name&rsquo;</li>
  <li>Both may define one or more properties, each with a name and Type</li>
  <li>Both may define encapsulated methods</li>
</ul>
 However a <el-code>record</el-code> differs  from a <el-code>class</el-code> in that:</p>
 <ul>
  <li>A <el-code><el-kw>record</el-kw></el-code> is immutable (like a <el-code>ListImmutable</el-code> or a <el-code>String</el-code>). You can create a copy with specified differences but you cannot modify a <el-code><el-kw>property</el-kw></el-code> on a given instance.</li>
  <li>A <el-code><el-kw>record</el-kw></el-code> instance may be created or copied using a <el-code>with</el-code> clause, whereas <el-code>with</el-code> may not be used on a class instance.</li>
  <li>A <el-code><el-kw>record</el-kw></el-code> does not define a constructor</li>
  <li>A <el-code><el-kw>record</el-kw></el-code> may define only <i>function</i> methods, since <i>procedure</i> methods would imply the ability to <i>mutate</i> the record.</li>
</ul>
Examples:
<el-code-block source="record_Square.elan">
<el-class class="ok multiline" id="class203" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>record </el-kw><el-field id="type204" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place>Name</el-place></el-field></el-top>
<el-prop class="ok" id="prop207" tabindex="0"><el-kw>property </el-kw><el-field id="ident208" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type209" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop210" tabindex="0"><el-kw>property </el-kw><el-field id="ident211" class="ok" tabindex="0"><el-txt><el-id>y</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type212" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-kw>end record</el-kw>
</el-class>
</el-code-block>
<el-code-block source="record_Game.elan">
<el-class class="ok multiline" id="class168" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>record </el-kw><el-field id="type169" class="ok" tabindex="0"><el-txt><el-type>Game</el-type></el-txt><el-place>Name</el-place></el-field></el-top>
<el-prop class="ok" id="prop172" tabindex="0"><el-kw>property </el-kw><el-field id="ident173" class="ok" tabindex="0"><el-txt><el-id>head</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type174" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop175" tabindex="0"><el-kw>property </el-kw><el-field id="ident176" class="ok" tabindex="0"><el-txt><el-id>body</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type177" class="ok" tabindex="0"><el-txt><el-type>ListImmutable</el-type>&lt;<el-kw>of</el-kw> <el-type>Square</el-type>&gt;</el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop178" tabindex="0"><el-kw>property </el-kw><el-field id="ident179" class="ok" tabindex="0"><el-txt><el-id>priorTail</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type180" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop181" tabindex="0"><el-kw>property </el-kw><el-field id="ident182" class="ok" tabindex="0"><el-txt><el-id>apple</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type183" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop184" tabindex="0"><el-kw>property </el-kw><el-field id="ident185" class="ok" tabindex="0"><el-txt><el-id>isOn</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type186" class="ok" tabindex="0"><el-txt><el-type>Boolean</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop187" tabindex="0"><el-kw>property </el-kw><el-field id="ident188" class="ok" tabindex="0"><el-txt><el-id>rnd</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type189" class="ok" tabindex="0"><el-txt><el-type>Random</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop190" tabindex="0"><el-kw>property </el-kw><el-field id="ident191" class="ok" tabindex="0"><el-txt><el-id>graphics</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type192" class="ok" tabindex="0"><el-txt><el-type>BlockGraphics</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop193" tabindex="0"><el-kw>property </el-kw><el-field id="ident194" class="ok" tabindex="0"><el-txt><el-id>key</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type195" class="ok" tabindex="0"><el-txt><el-type>String</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-kw>end record</el-kw>
</el-class>
</el-code-block>
Having defined a record Type, such as <el-code>Game</el-code> above, you can create as many instances as you wish using the following syntax to specify the values:
<el-code-block source="newGame from snake_FP.elan">
<el-statement class="ok" id="let603" tabindex="0"><el-kw>let </el-kw><el-field id="var604" class="ok" tabindex="0"><el-txt><el-id>g1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr605" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Game</el-type>()<el-kw> with </el-kw><br><el-id>head</el-id><el-kw> set to </el-kw><el-method>newSquare</el-method>(<el-lit>22</el-lit>, <el-lit>15</el-lit>), <br><el-id>key</el-id><el-kw> set to </el-kw>"<el-lit>d</el-lit>", <br><el-id>isOn</el-id><el-kw> set to </el-kw><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
Note that you are not <em>required</em> to provide a value for each property because, where a property is not specified in the &lsquo;<el-code>with</el-code> clause&rsquo; (as above), that property will be given the empty (default) value of the correct Type.</p>
<p>You can then read the values from the properties using &lsquo;dot syntax&rsquo; for example:</p>
<el-code-block source=""><el-statement class="" id="print15" tabindex="0"><el-kw>print </el-kw><el-field id="expr16" class="optional" tabindex="0"><el-txt><el-id>sq</el-id>.<el-id>size</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg></el-statement>
</el-code-block>
<p><el-code><el-kw>record</el-kw></el-code> Types are immutable: the properties on an instance may not be changed, directly.
  However, you can easily create another instance that is a copy of the original,
  with all the same property values except for any specific changes made in another <el-code>with</el-code> clause.
  The newly-minted copy (with changes) must be assigned to a new named value. For example:</p>
<el-code-block>
  <el-statement class="" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>sq1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>()<el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.5</el-lit>, <br><el-id>y</el-id><el-kw> set to </el-kw><el-lit><el-lit>4</el-lit>.0</el-lit>, <br><el-id>size</el-id><el-kw> set to </el-kw><el-lit><el-lit>1</el-lit>.0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="error"></el-msg></el-statement>
</el-code-block>
<el-code-block>
  <el-statement class="" id="let10" tabindex="0"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>sq2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>sq1</el-id><el-kw> with </el-kw><br><el-id>size</el-id><el-kw> set to </el-kw><el-lit><el-lit>2</el-lit>.0</el-lit>, <br><el-id>colour</el-id><el-kw> set to </el-kw><el-id>red</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg></el-statement>
</el-code-block>
Or even to the same name if that name is a variable:</p>
<el-code-block>
  <el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>()<el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.5</el-lit>, <br><el-id>y</el-id><el-kw> set to </el-kw><el-lit><el-lit>4</el-lit>.0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<el-code-block>
  <el-statement class="ok" id="set6" tabindex="0"><el-kw>set </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>a</el-id><el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.7</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<p>This last example shows how you enter the comma-separated <el-code>with</el-code> clauses. The earlier examples show how the Editor displays a set of <el-code>with</el-code> clauses.</p>

<p>If you want to use one or more existing property values in order to determine a new value, the property names must be prefixed with the name of the instance being copied, for example:</p>
<el-code-block>
  <el-statement class="" id="let9" tabindex="0"><el-kw>let </el-kw><el-field id="var10" class="ok" tabindex="0"><el-txt><el-id>sq2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr11" class="" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>sq1</el-id><el-kw> with </el-kw><br><el-id>size</el-id><el-kw> set to </el-kw><el-id>sq1</el-id>.<el-id>size</el-id> + <el-lit>3</el-lit></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class=""></el-msg></el-statement>
</el-code-block>
</p>

<h4 class="no-TOC">Record deconstruction</h4>
<p>A record may be &lsquo;deconstructed&rsquo;, meaning that its properties are read into separate variables using the same syntax as for deconstructing a <span class="Link">Tuple</span>. For example, assuming that Square is a record defined as in the example above, then this code:</p>
<el-code-block>
  <el-statement class="" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>x</el-id>, <el-id>y</el-id>, <el-id>size</el-id>, <el-id>colour</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="" tabindex="0"><el-txt><el-id>mySquare</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg></el-statement>
</el-code-block>
<p>will read the <el-code>properties</el-code> into the four names defined.</p>
When deconstructing, the names of the values must match the names of the <el-code>properties</el-code> of the <el-code><el-kw>record</el-kw></el-code>. However, the ordering of the names does not have to match the order in which the <el-code>properties</el-code> are defined in the <el-code><el-kw>record</el-kw></el-code>.
<!-- #endregion-->
<!--     #region Class-->
<h3 id="class">Class</h3>

<p>See also: <a href="inherits">Inheritance</a></p>

<p>A <el-code>class</el-code> is a user-defined Type offering far richer capability than an <el-code>enum</el-code>. </p>
<p>Note that a <el-code><el-kw>record</el-kw></el-code> is in some ways similar to a <el-code>class</el-code> but simpler: it defines properties, but has no constructor and no methods. See <a href="">Working with records</a>.</p>

<h4 class="no-TOC">Definition</h4>
<p>Here is an example of <el-code>class</el-code> definition, taken from the Snake OOP demo program:</p>
<el-code-block source="class_Apple.elan">
<el-class class="ok multiline" id="class177" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>class </el-kw><el-field id="type178" class="ok" tabindex="0"><el-txt><el-type>Apple</el-type></el-txt><el-place>Name</el-place></el-field> <el-field id="text179" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>inherits ClassName(s)</i></el-place></el-field></el-top>
<el-prop class="ok" id="prop181" tabindex="0"><el-kw>property </el-kw><el-field id="ident182" class="ok" tabindex="0"><el-txt><el-id>location</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type183" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-proc class="ok multiline" id="proc184" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident186" class="ok" tabindex="0"><el-txt>newRandomPosition</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params187" class="optional ok" tabindex="0"><el-txt><el-id>snake</el-id> <el-kw>as</el-kw> <el-type>Snake</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)</el-top>
<el-statement class="ok multiline" id="repeat188" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>repeat</el-kw></el-top>
<el-statement class="ok" id="let191" tabindex="0"><el-kw>let </el-kw><el-field id="var192" class="ok" tabindex="0"><el-txt><el-id>ranX</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr193" class="ok" tabindex="0"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-lit>39</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let194" tabindex="0"><el-kw>let </el-kw><el-field id="var195" class="ok" tabindex="0"><el-txt><el-id>ranY</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr196" class="ok" tabindex="0"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-lit>29</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set197" tabindex="0"><el-kw>set </el-kw><el-field id="ident198" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>location</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr199" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-id>ranX</el-id>, <el-id>ranY</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end repeat when </el-kw><el-field id="expr190" class="ok" tabindex="0"><el-txt><el-kw>not</el-kw> <el-id>snake</el-id>.<el-method>bodyCovers</el-method>(<el-kw>property</el-kw>.<el-id>location</el-id>)</el-txt><el-place><i>condition</i></el-place></el-field>
</el-statement>
<el-kw>end procedure</el-kw>
</el-proc>
<el-func class="ok multiline" id="func200" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident202" class="ok" tabindex="0"><el-txt>updateGraphics</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params203" class="optional ok" tabindex="0"><el-txt><el-id>gr</el-id> <el-kw>as</el-kw> <el-type>BlockGraphics</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type204" class="ok" tabindex="0"><el-txt><el-type>BlockGraphics</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return205" tabindex="0"><el-kw>return </el-kw><el-field id="expr206" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>location</el-id>.<el-method>updateGraphics</el-method>(<el-id>gr</el-id>, <el-id>red</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
<el-kw>end class</el-kw>
</el-class>
</el-code-block>
<p>A <el-code>class</el-code> must have a name that, like any other Type, begins with an upper case letter.</p>
<p>A class may define:</p>
<ul>
<li>One or more properties &ndash; see <a href="#property">Property</a></li>
<li><el-code>function</el-code> methods &ndash; see <span class="Link">Function method</span></li>
<li><el-code>procedure</el-code> methods &ndash; see <span class="Link">Procedure method</span></li>
<li>a <el-code>constructor</el-code> which may be used for setting up the values of properties. The <el-code>constructor</el-code> may optionally define parameters to force the calling code to provide initial values. However, it is not necessary to add a <el-code>constructor</el-code> if you have no need to initialise properties. Code in the constructor may make use of any functions, and follows the same constraints as a <el-code>function</el-code> (i.e. it may not call any <el-code>procedure</el-code>, whether defined on the <el-code>class</el-code> or outside).</li>
</ul>

<h3>Using a class</h3>
<p>A <el-code>class</el-code> is instantiated using the keyword <el-code>new</el-code> followed by the class name and brackets, which should enclose the comma-separated arguments required to match the parameters (if any) defined on the constructor for that <el-code>class</el-code>. For example (also from the Snake OOP demo):</p>
<el-code-block source="constructor.elan">
<el-constructor class="ok multiline" id="constructor41" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>constructor</el-kw>(<el-field id="params43" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>parameter definitions</i></el-place><el-compl><i>parameter definitions</i></el-compl></el-field>)</el-top>
<el-statement class="ok" id="let44" tabindex="0"><el-kw>let </el-kw><el-field id="var45" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr46" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-lit>20</el-lit>, <el-lit>15</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set47" tabindex="0"><el-kw>set </el-kw><el-field id="ident48" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>currentDir</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr49" class="ok" tabindex="0"><el-txt><el-type>Direction</el-type>.<el-id>right</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set50" tabindex="0"><el-kw>set </el-kw><el-field id="ident51" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>body</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr52" class="ok" tabindex="0"><el-txt>[<el-id>tail</el-id>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set53" tabindex="0"><el-kw>set </el-kw><el-field id="ident54" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>head</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr55" class="ok" tabindex="0"><el-txt><el-id>tail</el-id>.<el-method>getAdjacentSquare</el-method>(<el-kw>property</el-kw>.<el-id>currentDir</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set56" tabindex="0"><el-kw>set </el-kw><el-field id="ident57" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>priorTail</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr58" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end constructor</el-kw>
</el-constructor>
</el-code-block>
<p>The created instance may then be used within expressions, like any other variable.</p>

<h3 id="inherits">Inheritance</h2>
  <p>An ordinary <a href="class">class</a> (also known as a &lsquo;concrete class&rsquo;) may optionally inherit from just one <a href="Abstract_class"><el-code>abstract class</el-code></a>
    but may additionally inherit from any number of <a href="interface">interfaces</a>.
    The concrete class must define for itself a concrete implementation of every <em>abstract</em> member defined in the <el-code>abstract class</el-code> or any <el-code>interface</el-code>s that it inherits from, directly or indirectly.</p>
Notes:
<ul>
  <li>An <el-code>abstract class</el-code> must be declared in the code above any class that inherits from it. This is the only case where the order of definition (of global constructs) matters.</li>
  <li>The <el-code>abstract class</el-code> (if any) and the interfaces (if any) that a concrete <el-code>class</el-code> inherits from may not contain duplicates of any <el-code>abstract</el-code> member. Any duplicated definitions in the hierarchy will result in a compile error. If such duplications arise, you should factor out the common member definitions, and move them up the hierarchy or into new <el-code>interface</el-code>s inherited by the<el-code> interface</el-code>s and/or classes that need them.</li>
  <li>Inheritance hierarchies must form a tree, that is you must avoid creating a &lsquo;circular&rsquo; dependency where, for example, Type <el-code>A</el-code> inherits from Type <el-code>B</el-code>, which inherits from Type <el-code> C</el-code>, which inherits from Type <el-code>A</el-code>.</li>
  <li>The various &lsquo;super-Types&rsquo; (abstract classes and <el-code>interface</el-code>s) that a concrete <el-code>class</el-code> inherits from must not define conflicting members, e.g. members with the same name but having different Type signatures.</li>
</ul>
<!-- #endregion-->
<!--     #region Abstract Class-->
<h3 id="Abstract_class">Abstract Class</h3>
<p>See also: <a href="inherits">Inheritance</a></p>
<p>An <el-code>abstract class</el-code> may not be instantiated (and hence may not define a constructor). It may define concrete members i.e.:</p>
<ul>
<li>a <el-code><el-kw>property</el-kw></el-code> </li>
<li>a <el-code>function</el-code></li>
<li>a <el-code>procedure</el-code></li>
</ul>
<p>As with a concrete class, any of these members may be made <el-code>private</el-code>, after the corresponding frame has been added, by selecting that member frame and pressing Ctrl-p.</p>
<p>These concrete members are automatically inherited by any subclass, but they may not be overridden (re-defined) by the subclass. Therefore you should define concrete members only if they are intended to work identically on every subclass.</p>
<p id="Abstract_function" id="Abstract_procedure" id="Abstract_property">You may also define abstract methods on an <el-code>abstract class</el-code>, i.e. <el-code>abstract property</el-code>, <el-code>abstract function</el-code>, <el-code>abstract procedure</el-code>. Such methods define only the signature of the method, not the implementation (body), therefore they have no <el-code>end</el-code> statement. For example:</p>
<el-code>abstract function calculateDiscount() as Float</el-code></p>
<p>
If you wish to have several subclasses of an <el-code>abstract class</el-code> that share a common implementation for a method, but require that some of the subclasses can define a different implementation, then you should:</p>
<ul>
<li>Define the method as <el-code>abstract</el-code> on the superclass.</li>
<li>Define a concrete implementation on the superclass with a similar, but slightly different, name e.g. by adding a prefix such as: <el-code>default</el-code>.</li>
<li>Each subclass must then define its implementation of the abstract method, but the ones needing a common implementation can be just one line, delegating responsibility up to the &lsquo;default&rsquo; method on the superclass. </li>
</ul>
<!-- #endregion-->
<!--     #region Interface-->
<h3 id="interface">Interface</h3>
<p>See also: <a href="inherits">Inheritance</a></p>
<p>An <el-code>interface</el-code> is similar to an <el-code>abstract class</el-code>, with the difference that it may define only abstract members. The advantage of using an <el-code>interface</el-code> instead of an <el-code>abstract class</el-code> is that a concrete<el-code> class</el-code> can inherit from multiple <el-code>interface</el-code>s. See <span class="Link">Inheritance</span>.</p>
<p>An <el-code>interface</el-code> may inherit only from other <el-code>interface</el-code>s.</p>
<p>Important: An <el-code>interface</el-code> must not re-declare abstract interfaces that are defined in any <el-code>interface</el-code> it inherits from, directly or indirectly.</p>
<!--     #endregion-->
<!--   #endregion-->
<!--   #region Member Instructions-->
<!--     #region Heading & Intro-->
<h2 id="Member">Member Instructions</h2>
<p>When you navigate to a <el-code>new code</el-code> that is at <em>member</em> level
  (located directly within a <a href="#record">record</a>, <a href="#class">class</a>, <a href="#abstract_class"><el-code>abstract class</el-code></a>, or <a href="#interface">interface</a>)
  you will be shown the set of statements that may be inserted there, for example:</p>

  <el-code><el-member class="selected focused ok empty" id="select8" tabindex="0"><el-select><el-txt></el-txt><el-place>new code</el-place></el-select></el-member></el-code>

  <p>The specific members offered will depend upon the context, and/or upon your user profile.
    The full set of entries is shown here, with links to explanations below:</p>

    <a href="#constructor">constructor</a>,
    <a href="#property">property</a>,
    <a href="#procedure">procedure</a>,
    <a href="#function">function</a>,
    <a href="#abstract_property">abstract property</a>,
    <a href="#abstract_procedure">abstract procedure</a>,
    <a href="#abstract_function">abstract function</a>,
    <a href="#property">private property</a>,
    <a href="#procedure">private procedure</a>,
    <a href="#function">private function</a>,
    <a href="#comment">#</a>
<!-- #endregion-->
<!--     #region Constructor-->
<h3 id="constructor">Constructor</h3>
<p>A concrete class <em>may</em> define a single <el-code>constructor</el-code>, which may:</el-code></p>
<ul>
<li>initialise any properties with fixed values</li>
<li>define one or more parameters, which are then used to initialise properties</li>
</ul>
<p>If a class does define a constructor, and the constructor defines any parameters, then when the class is instantiated (using <el-code>new</el-code>) then values of
the correct types must be provided, for example, if the class <el-code><el-type>Snake</el-type></el-code> defines this constructor:</thead></p>

<el-code-block>
  <el-constructor class="ok multiline" id="constructor211" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>constructor</el-kw>(<el-field id="params213" class="optional ok" tabindex="0"><el-txt><el-id>x</el-id> <el-kw>as</el-kw> <el-type>Int</el-type>, <el-id>y</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)</el-top>
    <el-statement class="ok" id="set214" tabindex="0"><el-kw>set </el-kw><el-field id="ident215" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>x</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr216" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="set217" tabindex="0"><el-kw>set </el-kw><el-field id="ident218" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>y</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr219" class="ok" tabindex="0"><el-txt><el-id>y</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-kw>end constructor</el-kw>
  </el-constructor>
</el-code-block>

<p>then it may be instantiated like this:</p>

<el-code>
<el-statement class="selected focused ok" id="let44" tabindex="0"><el-kw>let </el-kw><el-field id="var45" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr46" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-lit>20</el-lit>, <el-lit>15</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code>
<!-- #endregion-->
<!--     #region Property-->
<h3 id="property">Property</h3>
<p>Examples:</p>
<el-code>property height as Int</el-code><br>
<el-code>property board as Board</el-code><br>
<el-code>property head as Square</el-code><br>
<el-code>property body as [Square]</el-code><br>
<ul>
<li>A <el-code><el-kw>property</el-kw></el-code> is defined on a <span class="Link">Class</span> and must <el-code>specify</el-code> a name (conforming to the rules for an <a href="#Identifier">Identifier</a> and a Type.</li>
<li>A <el-code><el-kw>property</el-kw></el-code> may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and pressing Ctrl-p. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
<li>If not marked <el-code>private</el-code>, a property may be read but not be written to. Properties may only be modified from outside the class by means of a <span class="Link">Procedure method</span>.</li>
<li>A property may be given an initial value in the <el-code>constructor</el-code>.</li>
</ul>
<p>
If the <el-code><el-kw>property</el-kw></el-code> is not initialised within the constructor then it will automatically be given the <el-code>empty</el-code> value for that Type. You may test whether a property contains this default value by writing e.g.:<br>
<el-code>if head is empty Square</el-code></p>
<ul>
<li>Whenever you wish to access a property from within a method (or from within the constructor) on the same class, then the name of the property must be prefixed with the &lsquo;qualifier&rsquo;: <el-code>property. </el-code>(&lsquo;property-dot&rsquo;). This applies whether you are reading or setting the property. By this means you can have a method parameter with the same name as a property, but they are unambiguous, because the property must be prefixed. A common pattern is to use the same name in a &lsquo;setter&rsquo; method, for example:</li>
</ul>
<el-code>constructor(board as Board)</el-code><br>
<el-code>  set property.board to board</el-code><br>
<el-code>end constructor</el-code><br>
<br>
<el-code>procedure setHeight(height as Int)</el-code><br>
<el-code>  set property.height to height</el-code><br>
<el-code>end procedure</el-code><br>
<!-- #endregion-->
<!--     #region Procedure Method-->
<h3 id="procedure_method">Procedure Method</h3>
<p>A &lsquo;procedure method&rsquo; follows the same syntax and rules as a global <a href="procedure">procedure</a>. The differences are:</p>
<ul>
<li>A procedure method, like a function method, is always referenced (used) by code outside the class using &lsquo;dot syntax&rsquo; on an instance.</li>
<li>A procedure method may read, or write to, any <el-code><el-kw>property</el-kw></el-code> defined on the class.</li>
<li>A procedure method may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and then pressing Ctrl-p. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
</ul>
<!-- #endregion-->
<!--     #region Function Method-->
<h3 id="function_method">Function Method</h3>
<p>A function method follows the same syntax and rules as a global <a href="function">function</a>>. The differences are:</p>
<ul>
<li>A <el-code>function</el-code> method is always referenced (used) by code outside the class using &lsquo;dot syntax&rsquo; on an instance.</li>
<li>A <el-code>function</el-code> method may directly reference (read only) any <el-code><el-kw>property</el-kw></el-code> defined on the class as though it were a variable/parameter.</li>
<li>A <el-code>function</el-code> method may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and then pressing Ctrl-p. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
<li>asString() method</li>
<li>asString method. This is just a regular function method with a specific name, no parameters and returning a String. If defined for a class, then if an instance of the class is printed, the <el-code>asString</el-code> function method will automatically be used. Typically <el-code>asString</el-code> will return a string made up of one or more of the property values, perhaps with additional text, or the results of function calls.</li>
</ul>
<!-- #endregion-->
<!--     #region Abstract Property-->
<h3 id="Abstract_property">Abstract Property</h3>
<p>An abstract property may be defined only on an <a href="#Abstract_class"><el-code>abstract class</el-code></a>. Any concrete sub-class must then implement a concrete (regular) property to match.</p>
<!-- #endregion-->
<!--     #region Abstract Procedure Method-->
<h3 id="Abstract_procedure_method">Abstract Procedure Method</h3>
<p>An abstract procedure method may be defined only on an <a href="#Abstract_class"><el-code>abstract class</el-code></a>. Any concrete sub-class must then implement a concrete (regular) property to match.</p>

<!-- #endregion-->
<!--     #region Abstract Function Method-->
<h3 id="abstract_function_method">Abstract Function Method</h3>
<p>An abstract function method may be defined only on an <a href="#Abstract_class"><el-code>abstract class</el-code></a>. Any concrete sub-class must then implement a concrete (regular) property to match.</p>

<!-- #endregion-->
<!--     #endregion -->
<!--   #region Statement Instructions-->
<!--     #region Heading & Intro-->
<h2 id="Statement">Statement Instructions</h2>
<p>When you navigate to a <el-code>new code</el-code> that is at <em>statement</em> level
  (located within a <a href="#Global">global</a> or a <a href="#Member">member</a> instruction)
  you will be shown the set of statements that may be inserted there, for example:</p>

  <el-code><el-statement class="selected focused ok empty" id="select4" tabindex="0"><el-select><el-txt></el-txt><el-place>new code</el-place></el-select></el-statement></el-code>

  <p>The specific statements offered will depend upon the context, and/or upon your user profile.
    The full set of entries is shown here, with links to explanations below:</p>

<a href="#assert">assert</a>
<a href="#call">call</a>
<a href="#each">each</a>
<a href="#else">else</a>
<a href="#for">for</a>
<a href="#if">if</a>
<a href="#let">let</a>
<a href="#print">print</a>
<a href="#repeat">repeat</a>
<a href="#set">set</a>
<a href="#throw">throw</a>
<a href="#try">try</a>
<a href="#variable">variable</a>
<a href="#while">while</a>
<a href="#comment">#</a>
<!--     #endregion-->
<!--     #region Assert statement-->
<h3 id="assert">Assert statement</h3>
<!--     #endregion-->
<!--     #region Procedure Call-->
<h3 id="call">Procedure Call</h3>
<!--     #endregion-->
<!--     #region Each loop-->
<h3 id="each">Each loop</h3>
<!--     #endregion-->
<!--     #region Else clause-->
<h3 id="else">Else clause</h3>
<!--     #endregion-->
<!--     #region For loop-->
<h3 id="for">For loop</h3>
<p>The loop counter variable does not have to have been defined in a <el-code>variable</el-code> statement.</p>
<p>The three defining values (<el-code>from</el-code>, <el-code>to</el-code>, and <el-code>step</el-code>) must all be integer, positive or negative.</p>
<p>They may be defined by literal integers, variables of Type <el-code>Int</el-code>, or expressions that evaluate to an integer. </p>
<p>However, if you require a negative step then the literal value, variable, or expression must start with a negative sign as this is needed at compile time to determine the nature of the exit condition. So if you have a variable <el-code>s</el-code> that holds a negative value to be used as the step, then you will need to write something like the following:</p>
<el-code-block>
variable s set to -3<br>
for i from 100 to 0 step -(-s)<br>
&nbsp;&nbsp;..<br>
end for
</el-code-block>
<!--     #endregion-->
<!--     #region If statement-->
<h3 id="if_statement">If statement</h3>
<p>See also <a href="if_expression">if expression</a></p>

Example 1:
<el-code-block
  <el-statement class="multiline" id="if3" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr5" class="" tabindex="0"><el-txt><el-id>head</el-id><el-kw> is </el-kw><el-id>apple</el-id></el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top> <el-msg class=""></el-msg>
    <el-statement class=""" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>setAppleToRandomPosition</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional " tabindex="0"><el-txt><el-id>apple</el-id>, <el-id>body</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>) <el-msg class="">'setAppleToRandomPosition' is not defined</el-msg></el-top></el-statement>
    <el-statement class="ok outdent" id="else9" tabindex="0"><el-top>
<el-kw>else </el-kw><el-field id="elif11" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>if</i></el-place></el-field></el-top></el-statement>
    <el-statement class="" id="call12" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident13" class="" tabindex="0"><el-txt><el-id>body</el-id>.<el-method>removeAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args14" class="optional ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>arguments</i></el-place></el-field>) <el-msg class=""></el-msg></el-top></el-statement>
    <el-kw>end if</el-kw>
    </el-statement>
</el-code-block>

Example 2:
<el-code><br>
if item is value then<br>
&nbsp;&nbsp;set result to true<br>
else if item.isBefore(value) then<br>
&nbsp;&nbsp;set result to binarySearch(list[..mid], item)<br>
else<br>
&nbsp;&nbsp;set result to binarySearch(list[mid + 1..], item)<br>
end if
</el-code>
Notes:
<ul>
<li>The <el-code>else</el-code> clause is optional</li>
<li>You can add as many <el-code>else if</el-code> clauses as you wish, but only one unconditional <el-code>else</el-code> (which, if present, must be the last clause).</li>
</ul>
<!--     #endregion-->
<!--     #region Let statement-->
<h3 id="let">Let statement</h3>
<!--     #endregion-->
<!--     #region Print statement-->
<h3 id="print">Print statement</h3>

The simplest way to print is with the <el-code>print</el-code> statement. For example:

<el-code-block>
  <main class="ok multiline" id="main3" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>main</el-kw></el-top>
    <el-statement class="ok" id="print5" tabindex="0"><el-kw>print </el-kw><el-field id="expr6" class="optional ok" tabindex="0"><el-txt>"<el-lit>Hello</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="let7" tabindex="0"><el-kw>let </el-kw><el-field id="var8" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-lit>3</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="let10" tabindex="0"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>b</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-lit>4</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="print13" tabindex="0"><el-kw>print </el-kw><el-field id="expr14" class="optional ok" tabindex="0"><el-txt><el-id>a</el-id>*<el-id>b</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="print15" tabindex="0"><el-kw>print </el-kw><el-field id="expr16" class="optional ok" tabindex="0"><el-txt>"<el-lit></el-lit>{<el-id>a</el-id>}<el-lit> times </el-lit>{<el-id>b</el-id>}<el-lit> equals </el-lit>{<el-id>a</el-id>*<el-id>b</el-id>}<el-lit></el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-kw>end main</el-kw>
  </main>
</el-code-block>

Note:
<ul>
<li>The last line in the example above uses an <a href="#Interpolated_string">interpolated string</a>. Arguments placed within curly braces are evaluated before printing, and these may be separated by literal text and punctuation as needed. This is one recommended way to print more than one value on a line. The other way is to use print procedures.</li>
</ul>
<!--     #endregion-->
<!--     #region Repeat loop-->
<h3 id="repeat">Repeat loop</h3>
<!--     #endregion-->
<!--     #region Set statement-->
<h3 id="set">Set statement</h3>
<!--     #endregion-->
<!--     #region Throw statement-->
<h3 id="throw">Throw statement</h3>
<p>You can deliberately generate, or &lsquo;throw&rsquo;, an exception when a specific circumstance is identified with a <el-code>throw</el-code> statement, for example:</p>
<el-code>throw exception "something has happened"</el-code><br>
<!--     #endregion-->
<!--     #region Try statement-->
<h3 id="try">Try statement</h3>

Where another piece of code might throw an exception, for example when calling a <a href="#System_methods">System method</a> that is dependent upon external conditions, it may be executed within a <el-code>try</el-code> statement, for example:
<el-code-block source="tryCatch.elan">
<el-statement class="ok multiline" id="try18" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>try </el-kw></el-top>
<el-statement class="ok" id="call38" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident39" class="ok" tabindex="0"><el-txt><el-method>foo</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args40" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print47" tabindex="0"><el-kw>print </el-kw><el-field id="expr48" class="optional ok" tabindex="0"><el-txt>"<el-lit>not caught</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline outdent" id="catch20" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>catch exception in </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>variableName</i></el-place></el-field></el-top>
<el-statement class="ok" id="print64" tabindex="0"><el-kw>print </el-kw><el-field id="expr65" class="optional ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-statement>
<el-kw>end try</el-kw>
</el-statement>
</el-code-block>
The variable holding the exception (by default named <el-code>e</el-code>, but this may be changed by you) is of Type <el-code>String</el-code>. You may compare the exception message to one or more expected messages and, if the message does not match an expected exception, you may choose to throw the exception &lsquo;up&rsquo;, as in this example:
<el-code-block source="tryCatch.elan">
<el-statement class="ok multiline" id="try141" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>try </el-kw></el-top>
<el-statement class="ok" id="call158" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident159" class="ok" tabindex="0"><el-txt><el-method>foo</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args160" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print177" tabindex="0"><el-kw>print </el-kw><el-field id="expr178" class="optional ok" tabindex="0"><el-txt>"<el-lit>not caught</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline outdent" id="catch143" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>catch exception in </el-kw><el-field id="ident145" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>variableName</i></el-place></el-field></el-top>
<el-statement class="ok multiline" id="if211" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr213" class="ok" tabindex="0"><el-txt><el-id>e</el-id><el-kw> isnt </el-kw>"<el-lit>an expected message</el-lit>"</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="throw234" tabindex="0"><el-kw>throw exception </el-kw><el-field id="msg235" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>message</i></el-place></el-field></el-statement>
<el-kw>end if</el-kw>
</el-statement>
</el-statement>
<el-kw>end try</el-kw>
</el-statement>
</el-code-block>
<!--     #endregion-->
<!--     #region Variable statement-->
<h3 id="variable">Variable statement</h3>
<!--     #endregion-->
<!--     #region While loop-->
<h3 id="while">While loop</h3>
<!-- #endregion -->
<!--   #endregion -->
<!-- #endregion -->
<!-- #region Expressions-->
<!--   #region Heading & Intro-->
<h1 id="Expression">Expressions</h1>
<p>One of the most important constructs in programming is the &lsquo;expression&rsquo;. An expression is evaluated to return a value. An expression is made up of the following possible elements:</p>
<ul>
<li>Literal value</li>
<li>Named value</li>
<li>Operator (including brackets)</li>
<li>Function call</li>
</ul>
<p>which this chapter describes.</p>
<!--   #endregion-->
<!--   #region Literal value-->
<h3 id="Literal_value">Literal value</h3>
<p>A literal value is where a value is written &lsquo;literally&rsquo; in the code, such as <el-code>3.142</el-code> &ndash; in contrast to a value that is referred to by a name.</p>
<p>The following data Types may be written as literal values (follow the links to view the form of each literal value):</p>
<el-code><a href="#Int">Int</a>, <a href="#Float">Float</a>, <a href="#Boolean">Boolean</a>, <a href="#String">String</a>, <a href="#List">List</a>, <a href="#ListImmutable">ListImmutable</a>, <a href="#Dictionary">Dictionary</a>, <a href="#DictionaryImmutable">DictionaryImmutable</a>, <a href="#Tuple">Tuple</a></el-code><br>
<!--   #endregion-->
<!--   #region Named value-->
<h3 id="Named_value">Named value</h3>
<p>A named value is a value that is associated with a name rather than being defined literally in code. There are various kinds of named value:</p>
<p><a href="#Constant">Constant</a>, <span class="Hyperlink"><a href="#Let_statement_1">let</a></span> statement, <span class="Hyperlink"><a href="#Variables">variable</a></span> statement, <a href="#Parameter_passing_1">Parameter passing</a>, <span class="Hyperlink"><a href="#Enum_1">enum</a></span> statement</p>
<!--   #endregion-->
<!--   #region Identifier-->
<h3 id="Identifier">Identifier</h3>
<p>For all kinds of named values, the name must follow the rules for an &lsquo;identifier&rsquo;. It must start with a lower case letter, followed by any combination of lower case and upper case letters, numeric digits, and the _ (underscore) symbol. It may not contain spaces or other symbols. Once a named value has been defined, it can be referred to by the name. </p>

<h3>Scoping and name qualification</h3>
<p>With the exception of a <el-code>constant</el-code> (below), which is global in scope, named values are always &lsquo;local&rsquo;: their scope is confined to the method in which they are defined. </p>
<p>Elan allows local named values to be defined with the same name as a constant, function, or procedure defined at global level or defined in the standard library. In such cases, when the name is used within the same method, then it will refer to the local definition. If you have done this, but then need to access the <el-code>constant</el-code>, <el-code>function</el-code>, or <el-code>procedure</el-code> with the same name, then you can simply prefix the use of the name with a &lsquo;qualifier&rsquo; of either <el-code>global.</el-code> or <el-code>library.</el-code> as appropriate.</p>
<!--   #endregion-->
<!--   #region Indexed Value-->
<h3>Indexed Value</h3>
If a variable is of an indexable Type, then an index or index range may be applied to the variable within an expression. For example:
<pre>
    <el-code>variable a set to "Hello World!"</el-code>
    <el-code>print a[4]</el-code>        &rarr; <el-code>o</el-code>
    <el-code>print a[4..]</el-code>    &rarr; <el-code>o World!</el-code>
    <el-code>print a[..7]</el-code>    &rarr; <el-code>Hello W</el-code>   (since the upper bound of a range is <em>exclusive</em>)
    <el-code>print a[0..4]</el-code>  &rarr; <el-code>Hell</el-code>         (for the same reason)
</pre>
<p>See also: <a href="#Using_a_List">Using an List</a>, <a href="#Using_a_Dictionary">Using a Dictionary</a></p>
<p>Important: unlike in many languages, indexes in Elan (whether, single, multiple, or a range) are only ever used for <em>reading</em> values.
Writing a value to a specific index location is done through a method such as in these examples:</p>
<pre>
    <el-code>putAt</el-code>            on a   <el-code>List</el-code>
    <el-code>withPut</el-code>        on a    <el-code>ListImmutable</el-code>
    <el-code>putAtKey</el-code>      on a    <el-code>Dictionary</el-code>
    <el-code>withPutKey</el-code>  on a    <el-code>DictionaryImmutable</el-code>
</pre>
<!--   #endregion-->
<!--   #region Operator-->
<h3 id="Operator">Operators</h3>

<h4 class="no-TOC" id="Arithmetic_operator">Arithmetic operators</h4>
<p>Arithmetic operators can be applied to <el-code>Float</el-code> or <el-code>Int</el-code> arguments, but the result is always a <el-code>Float</el-code>:</p>
<pre>
    <el-code>2^3</el-code>             &rarr;  <el-code>8</el-code>
    <el-code>2/3</el-code>             &rarr;  <el-code>0.666...</el-code>
    <el-code>2*3</el-code>             &rarr;  <el-code>6</el-code>
    <el-code>2 + 3</el-code>         &rarr;  <el-code>5</el-code>
    <el-code>2 - 3</el-code>         &rarr;  <el-code>-1</el-code>
    <el-code>11 mod 3</el-code>   &rarr;  <el-code>2</el-code> (integer remainder)
    <el-code>11 div 3</el-code>   &rarr;  <el-code>3</el-code> (integer division)
</pre>
<p>Arithmetic operators follow the conventional rules for precedence i.e. &lsquo;BIDMAS&rsquo; (or &lsquo;BODMAS&rsquo;).</p>
When combining <el-code>div</el-code> or <el-code>mod</el-code> with any other operators within an expression, insert brackets to avoid ambiguity e.g.:
<pre>
    <el-code>(5 + 6) mod 3</el-code>
</pre>
The minus sign may also be used as a unary operator, and this takes precedence over binary operators so:
<pre>
    <el-code>2*-3</el-code>           &rarr;  <el-code>-6</el-code>
</pre>
<p>Note that the Elan editor automatically puts spaces around the <el-code>+</el-code> and <el-code>&ndash;</el-code> binary operators, but not around <el-code>^</el-code>, <el-code>/</el-code> or <el-code>*</el-code>. This is just to visually reinforce the precedence.</p>

<h4 class="no-TOC" id="Logical_operator">Logical operators</h4>
<p>Logical operators are applied to <el-code>Boolean</el-code> arguments and return a <el-code>Boolean</el-code> result.</p>
<el-code>and</el-code> and <el-code>or</el-code> are binary operators<br>
<el-code>not</el-code> is a unary operator. </p>
The operator precedence is <el-code>not</el-code> &rarr; <el-code>and</el-code> &rarr; <el-code>or</el-code>, so this
example, which implements an &lsquo;exclusive or&rsquo;, need not use brackets and can rely on the operator precedence:</p>

<el-code-block source="xor.elan">
<el-func class="ok multiline" id="func3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident5" class="ok" tabindex="0"><el-txt>xor</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params6" class="optional ok" tabindex="0"><el-txt><el-id>a</el-id> <el-kw>as</el-kw> <el-type>Boolean</el-type>, <el-id>b</el-id> <el-kw>as</el-kw> <el-type>Boolean</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type7" class="ok" tabindex="0"><el-txt><el-type>Boolean</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-id>a</el-id><el-kw> and </el-kw><el-kw>not</el-kw> <el-id>b</el-id><el-kw> or </el-kw><el-id>b</el-id><el-kw> and </el-kw><el-kw>not</el-kw> <el-id>a</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw></el-func>
</el-code-block>

<h4 class="no-TOC">Equality testing</h4>
<p>Equality testing uses the <el-code>is</el-code> and <el-code>isnt</el-code> keywords with two arguments. The arguments may be of any Type.</p>
<ul>
<li><el-code>a is b</el-code> returns <el-code>true</el-code>, if <el-code>a</el-code> and <el-code>b</el-code> are both of the same Type and their values are equal. The only exception is that if one argument is of Type <el-code>Float</el-code> and the other is of Type <el-code>Int</el-code>, then <el-code>is</el-code> will return <el-code>true</el-code> if their values are the same, i.e. are the same whole number.</li>
<li><el-code>isnt</el-code> returns the opposite of <el-code>is</el-code></li>
<p>Note that in Elan equality testing is always &lsquo;equality by value&rsquo;; there is no such thing as &lsquo;equality by reference&rsquo;.</p>
<p>Note</p>
<li>Where a binary operator is expected, as soon as you type <el-code>is</el-code> the editor will automatically insert a space after it. To enter <el-code>isnt</el-code> you need to delete the space (using the Backspace key) and then type <el-code>nt</el-code>.</li>
</ul>

<h4 class="no-TOC">Numeric comparison</h4>
<p>The numeric comparison operators are:</p>
<pre>
    <el-code>&gt; </el-code>        for     greater than
    <el-code>&lt; </el-code>        for     less than
    <el-code>&gt;=</el-code>        for     greater than or equal to
    <el-code>&lt;=</el-code>        for     less than or equal to
</pre>
<p>Each is applied to two arguments of Type <el-code>Float</el-code>, but any variable or expression that evaluates to an <el-code>Int</el-code> may always be used where a <el-code>Float</el-code> is expected.</p>
Notes:
<ul>
<li>These operators cannot be applied to strings. Use the dot methods <el-code>isBefore</el-code> and <el-code>isAfter</el-code> to compare strings alphabetically. See <a href="#Dot_methods_on">Dot methods on a String</a>.</li>
<li>Where a binary operator is expected, as soon as you type <el-code>&lt; </el-code>or <el-code>&gt;</el-code> the editor will automatically insert a space after it. To enter <el-code>&lt;=</el-code> or <el-code>&gt;=</el-code> you need to delete the space (using the Backspace key) and then type <el-code>=</el-code>.</li>
</ul>

<h4 class="no-TOC">Combining operators </h4>
<p>You can combine operators of different kinds, e.g. combining numeric comparison with logical operators in a single expression. However the rules of precedence between operators of different kinds are complex. It is strongly recommend that you always use brackets to disambiguate such expressions, for example:</p>

<el-code-block source="combiningOperators.elan">
<el-field id="expr19" class="ok" tabindex="0"><el-txt>(<el-id>a</el-id> &gt; <el-id>b</el-id>)<el-kw> and </el-kw>(<el-id>b</el-id> &lt; <el-id>c</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field>
<br>
<el-field id="expr35" class="ok" tabindex="0"><el-txt>(<el-id>a</el-id> + <el-id>b</el-id>) &gt; (<el-id>c</el-id> - <el-id>d</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field>
</el-code-block>

<h3 id="function_call">Function call</h3>
An expression may simply be a function call, or it may include one or more function calls within it. Examples:
<el-code-block source="sinDeg.elan">
<el-statement class="ok" id="print5" tabindex="0"><el-kw>print </el-kw><el-field id="expr6" class="optional ok" tabindex="0"><el-txt><el-method>sinDeg</el-method>(<el-lit>30</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var7" tabindex="0"><el-kw>variable </el-kw><el-field id="var8" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-method>sinDeg</el-method>(<el-lit>30</el-lit>)^<el-lit>2</el-lit> + <el-method>cosDeg</el-method>(<el-lit>30</el-lit>)^<el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var10" tabindex="0"><el-kw>variable </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>name</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-method>inputString</el-method>("<el-lit>Your name</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print13" tabindex="0"><el-kw>print </el-kw><el-field id="expr14" class="optional ok" tabindex="0"><el-txt><el-id>name</el-id>.<el-method>upperCase</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
Notes:
<ul>
<li>The third example above is not strictly a function call, but is a &lsquo;system method&rsquo; call.
System methods may be used only within the <el-code>main</el-code> routine or a <el-code>procedure</el-code>, because they have external dependencies or side effects.</li>
<li>In the fourth example, <el-code>upperCase</el-code> is a &lsquo;dot method&rsquo; that may be applied to any instance (variable or literal) of Type <el-code>String</el-code>.
See <span class="Link">Dot methods on a String</span>.</li>
</ul>
<!--   #endregion-->
<!--   #region Lambda-->
<h3 id="lambda">Lambda</h3>
<p>A lambda is lightweight means to define a function &lsquo;in line&rsquo;. You typically define a <el-code>lambda</el-code>:</p>
<ul>
<li>If the functionality it defines is needed in only one location; typically for a particular call to a HoF.</li>
<li>If you need to capture a local variable in the implementation. This is called &lsquo;closing around a variable&rsquo;.</li>
<p>The syntax for a <el-code>lambda</el-code> is as follows:</p>
<li>Start with the keyword <el-code>lambda</el-code>.</li>
<li>Parameter definitions, comma-separated, follow the same form as parameter definitions in a function or procedure, but with out surrounding brackets.</li>
<li>The<el-code> =&gt;</el-code> symbol, which is usually articulated as &lsquo;returns&rsquo;,  &lsquo;yields&rsquo; or even &lsquo;fat arrow&rsquo;.</li>
<li>An expression that makes use of the parameters, and may also make use of other variables that are in scope. </li>
</ul>
Example:
<el-code-block source="liveNeighbours.elan">
<el-func class="ok multiline" id="func3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident5" class="ok" tabindex="0"><el-txt>liveNeighbours</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params6" class="optional ok" tabindex="0"><el-txt><el-id>cells</el-id> <el-kw>as</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Boolean</el-type>&gt;, <el-id>c</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type7" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="let10" tabindex="0"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>neighbours</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-method>neighbourCells</el-method>(<el-id>c</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let13" tabindex="0"><el-kw>let </el-kw><el-field id="var14" class="ok" tabindex="0"><el-txt><el-id>live</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr15" class="ok" tabindex="0"><el-txt><el-id>neighbours</el-id>.<el-method>filter</el-method>(<el-kw>lambda</el-kw> <el-id>i</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-id>cells</el-id>[<el-id>i</el-id>])</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-id>live</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw> </el-func>
</el-code-block>
Notes:
<ul>
<li>Although a lambda is commonly defined &lsquo;inline&rsquo; (as shown above) it is possible to assign a lambda to a variable and hence to re-use it within the scope of that variable.</li>
<li>Ana although a lambda will usually define at least one parameter, it is possible to define a lambda with no parameter &ndash; just returning an expression &ndash; in which case it acts just like a locally defined variable, but with the advantage (useful in rare circumstances) that the expression is evaluated &lsquo;lazily&rsquo; i.e. only when the lambda is used.</li>
</ul>
<p>The following example uses both these techniques within a function:</p>
<el-code-block source="safeSquareRoot.elan<el-func class="ok multiline" id="func1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident3" class="ok" tabindex="0"><el-txt>safeSquareRoot</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params4" class="optional ok" tabindex="0"><el-txt><el-id>x</el-id> <el-kw>as</el-kw> <el-type>Float</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type5" class="ok" tabindex="0"><el-txt><el-type>Float</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="let8" tabindex="0"><el-kw>let </el-kw><el-field id="var9" class="ok" tabindex="0"><el-txt><el-id>root</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr10" class="ok" tabindex="0"><el-txt><el-kw>lambda</el-kw> =&gt; <el-method>sqrt</el-method>(<el-id>x</el-id>)</el-txt><el-place><i>expression</i></el-place><el-compl><i>name</i> as <i>Type</i>, ...</el-compl></el-field></el-statement>
<el-statement class="ok" id="return6" tabindex="0"><el-kw>return </el-kw><el-field id="expr7" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-id>x</el-id> &lt; <el-lit>0</el-lit><el-kw> then </el-kw><el-lit>0</el-lit><el-kw><br>else </el-kw><el-method>root</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw></el-func>
</el-code-block>
<!--   #endregion-->
<!--   #region If expression-->
<h3 id="if_expression">If expression</h3>
The &lsquo;if expression&rsquo; is in certain respects similar to an <span class="Link">If statement</span>, but with the following differences:
<ul>
<li>It is written entirely within a single expression. This is possible because the <el-code>if</el-code> expression always returns a value.</li>
<li>There is always a single <el-code>then</el-code> and a single <el-code>else</el-code> clause, and each clause contains just a single expression. The <el-code>if</el-code> expression returns the result of evaluating one of these two expressions, according to whether the condition evaluates to <el-code>true</el-code> or <el-code>false</el-code>.</li>
</ul>
<p>Here are three examples:</p>
<el-code-block source="if_expression.elan">
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-id>c</el-id> &lt; <el-lit>1160</el-lit><el-kw> then </el-kw><el-id>c</el-id> + <el-lit>40</el-lit><el-kw><br>else </el-kw><el-id>c</el-id> - <el-lit>1160</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<br>
<el-statement class="ok" id="return25" tabindex="0"><el-kw>return </el-kw><el-field id="expr26" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-method>isGreen</el-method>(<el-id>attempt</el-id>, <el-id>target</el-id>, <el-id>n</el-id>)<el-kw> then </el-kw><el-method>setChar</el-method>(<el-id>attempt</el-id>, <el-id>n</el-id>, "<el-lit>*</el-lit>")<el-kw><br>else </el-kw><el-id>attempt</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<br>
<el-statement class="ok" id="return104" tabindex="0"><el-kw>return </el-kw><el-field id="expr105" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-id>attempt</el-id>[<el-id>n</el-id>]<el-kw> is </el-kw>"<el-lit>*</el-lit>"<el-kw> then </el-kw><el-id>attempt</el-id><el-kw><br>else </el-kw><el-kw>if </el-kw><el-method>isYellow</el-method>(<el-id>attempt</el-id>, <el-id>target</el-id>, <el-id>n</el-id>)<el-kw> then </el-kw><el-method>setChar</el-method>(<el-id>attempt</el-id>, <el-id>n</el-id>, "<el-lit>+</el-lit>")<el-kw><br>else </el-kw><el-method>setChar</el-method>(<el-id>attempt</el-id>, <el-id>n</el-id>, "<el-lit>_</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<!-- #endregion-->
<!-- #endregion-->
<b>Elan Language Reference</b> go to the <a href="#top">top</a></h4>
</body>
</html>